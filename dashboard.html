<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Nexus</title>
  <link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;600;700;800&family=DM+Sans:wght@300;400;500;600&display=swap" rel="stylesheet"/>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --bg: #0b0c10; --surface: #13151c; --surface2: #1c1f2b; --surface3: #242838;
      --accent: #5b6af0; --text: #eaedf8; --muted: #7c80a0;
      --border: rgba(255,255,255,0.07); --glow: rgba(91,106,240,0.3);
      --error: #ff5f57; --success: #23d18b; --online: #23d18b;
      --idle: #ffa726; --dnd: #ff5f57; --admin: #f59e0b;
      --mobile-nav-h: 60px;
    }
    html { height: 100%; }
    body { height: 100%; background: var(--bg); color: var(--text); font-family: 'DM Sans', sans-serif; display: flex; overflow: hidden; }

    /* ════════════════════════════════
       DESKTOP LAYOUT
    ════════════════════════════════ */
    .servers-bar { width: 72px; background: #080a0f; display: flex; flex-direction: column; align-items: center; padding: 12px 0; gap: 8px; border-right: 1px solid var(--border); flex-shrink: 0; overflow-y: auto; }
    .server-icon { width: 48px; height: 48px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 1.2rem; font-weight: 700; transition: border-radius 0.2s, background 0.2s; position: relative; flex-shrink: 0; user-select: none; }
    .server-icon:hover, .server-icon.active { border-radius: 16px; }
    .server-icon.home { background: var(--accent); color: #fff; font-size: 1.3rem; }
    .server-icon.home:hover, .server-icon.home.active { background: #4a59e0; }
    .server-icon.add { background: var(--surface2); color: var(--success); font-size: 1.5rem; border-radius: 50%; }
    .server-icon.add:hover { background: var(--success); color: #fff; border-radius: 16px; }
    .server-icon.admin-icon { background: var(--admin); color: #fff; font-size: 1.1rem; }
    .server-icon.admin-icon:hover, .server-icon.admin-icon.active { background: #d97706; }
    .server-divider { width: 32px; height: 2px; background: var(--border); border-radius: 1px; margin: 4px 0; }
    .server-pip { position: absolute; left: -4px; top: 50%; transform: translateY(-50%); width: 4px; border-radius: 0 2px 2px 0; background: var(--text); transition: height 0.2s; height: 0; }
    .server-icon:hover .server-pip { height: 20px; }
    .server-icon.active .server-pip { height: 36px; }

    .sidebar { width: 240px; background: var(--surface); display: flex; flex-direction: column; border-right: 1px solid var(--border); flex-shrink: 0; transition: transform 0.3s; }
    .sidebar-header { padding: 0 16px; height: 52px; border-bottom: 1px solid var(--border); font-family: 'Syne', sans-serif; font-weight: 700; font-size: 0.95rem; display: flex; align-items: center; justify-content: space-between; flex-shrink: 0; }
    .sidebar-search { padding: 8px 12px; flex-shrink: 0; }
    .sidebar-search input { width: 100%; background: var(--surface2); border: 1px solid var(--border); border-radius: 6px; padding: 7px 10px; color: var(--text); font-family: 'DM Sans', sans-serif; font-size: 0.82rem; outline: none; }
    .sidebar-search input::placeholder { color: var(--muted); }
    .sidebar-scroll { flex: 1; overflow-y: auto; }
    .sidebar-section-label { padding: 12px 12px 4px; font-size: 0.7rem; font-weight: 700; letter-spacing: 0.08em; color: var(--muted); text-transform: uppercase; display: flex; align-items: center; justify-content: space-between; }
    .sidebar-section-label .sl-btn { cursor: pointer; font-size: 1rem; opacity: 0.6; transition: opacity 0.2s; background: none; border: none; color: var(--muted); }
    .sidebar-section-label .sl-btn:hover { opacity: 1; }
    .sidebar-item { display: flex; align-items: center; gap: 10px; padding: 7px 12px; border-radius: 6px; margin: 1px 8px; cursor: pointer; transition: background 0.15s; font-size: 0.88rem; color: var(--muted); }
    .sidebar-item:hover { background: var(--surface2); color: var(--text); }
    .sidebar-item.active { background: var(--surface3); color: var(--text); }
    .item-avatar { width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.78rem; font-weight: 700; flex-shrink: 0; position: relative; overflow: hidden; }
    .item-avatar img { width: 100%; height: 100%; object-fit: cover; }
    .status-dot { position: absolute; bottom: -1px; right: -1px; width: 10px; height: 10px; border-radius: 50%; border: 2px solid var(--surface); }
    .status-dot.online { background: var(--online); }
    .status-dot.idle { background: var(--idle); }
    .status-dot.dnd { background: var(--dnd); }
    .status-dot.offline { background: var(--muted); }
    /* channel item */
    .channel-item { display: flex; align-items: center; gap: 8px; padding: 6px 12px; border-radius: 6px; margin: 1px 8px; cursor: pointer; transition: background 0.15s; font-size: 0.88rem; color: var(--muted); }
    .channel-item:hover { background: var(--surface2); color: var(--text); }
    .channel-item.active { background: var(--surface3); color: var(--text); }
    .channel-item .ch-lock { font-size: 0.7rem; margin-left: auto; opacity: 0.5; }

    .user-panel { padding: 10px 8px; border-top: 1px solid var(--border); display: flex; align-items: center; gap: 8px; cursor: pointer; border-radius: 8px; transition: background 0.15s; flex-shrink: 0; }
    .user-panel:hover { background: var(--surface2); }
    .user-panel-avatar { width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.9rem; color: #fff; flex-shrink: 0; overflow: hidden; }
    .user-panel-avatar img { width: 100%; height: 100%; object-fit: cover; }
    .user-panel-info { flex: 1; min-width: 0; }
    .user-panel-name { font-size: 0.85rem; font-weight: 600; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .user-panel-tag { font-size: 0.72rem; color: var(--muted); }
    .user-panel-actions { display: flex; gap: 4px; }
    .icon-btn { width: 28px; height: 28px; border-radius: 6px; background: none; border: none; color: var(--muted); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1rem; transition: background 0.15s, color 0.15s; }
    .icon-btn:hover { background: var(--surface3); color: var(--text); }

    .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; min-width: 0; }
    .main-header { padding: 0 16px; height: 52px; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 10px; flex-shrink: 0; }
    .main-header h2 { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 1rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .header-tabs { display: flex; gap: 4px; margin-left: 16px; }
    .tab { padding: 5px 12px; border-radius: 6px; font-size: 0.82rem; font-weight: 500; cursor: pointer; color: var(--muted); transition: background 0.15s, color 0.15s; border: none; background: none; font-family: 'DM Sans', sans-serif; white-space: nowrap; }
    .tab:hover { background: var(--surface2); color: var(--text); }
    .tab.active { background: var(--surface2); color: var(--text); }
    .add-friend-btn { margin-left: auto; padding: 6px 14px; background: var(--success); color: #fff; border: none; border-radius: 6px; font-family: 'DM Sans', sans-serif; font-size: 0.8rem; font-weight: 600; cursor: pointer; transition: background 0.2s; white-space: nowrap; flex-shrink: 0; }
    .add-friend-btn:hover { background: #1db97a; }
    .main-content { flex: 1; overflow-y: auto; padding: 20px; min-height: 0; }

    /* hamburger for mobile */
    .hamburger { display: none; background: none; border: none; color: var(--text); font-size: 1.4rem; cursor: pointer; padding: 4px; flex-shrink: 0; }

    /* ── FRIENDS ── */
    .friends-list { display: flex; flex-direction: column; gap: 2px; }
    .friend-row { display: flex; align-items: center; gap: 12px; padding: 10px 14px; border-radius: 10px; transition: background 0.15s; border-bottom: 1px solid var(--border); }
    .friend-row:hover { background: var(--surface2); }
    .friend-avatar { width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.95rem; color: #fff; flex-shrink: 0; position: relative; overflow: hidden; cursor: pointer; }
    .friend-avatar img { width: 100%; height: 100%; object-fit: cover; }
    .friend-info { flex: 1; cursor: pointer; min-width: 0; }
    .friend-name { font-weight: 600; font-size: 0.92rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .friend-status { font-size: 0.76rem; color: var(--muted); margin-top: 1px; }
    .friend-actions { display: flex; gap: 6px; flex-shrink: 0; }
    .friend-btn { width: 34px; height: 34px; border-radius: 50%; background: var(--surface2); border: none; color: var(--muted); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.95rem; transition: background 0.15s, color 0.15s; }
    .friend-btn:hover { background: var(--surface3); color: var(--text); }

    /* ── CHAT ── */
    .chat-view { display: flex; flex-direction: column; height: 100%; overflow: hidden; flex: 1; min-height: 0; }
    .chat-messages { flex: 1; overflow-y: auto; padding: 16px 16px 8px; display: flex; flex-direction: column; gap: 2px; min-height: 0; }
    .typing-indicator { flex-shrink: 0; }
    .chat-input-area { flex-shrink: 0; padding: 0 12px 12px; }
    .no-perm-bar { flex-shrink: 0; }
    .deactivated-bar { flex-shrink: 0; }
    .chat-msg { display: flex; gap: 12px; padding: 4px 6px; border-radius: 8px; transition: background 0.1s; }
    .chat-msg:hover { background: rgba(255,255,255,0.02); }
    .chat-msg-avatar { width: 38px; height: 38px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.85rem; color: #fff; flex-shrink: 0; overflow: hidden; cursor: pointer; }
    .chat-msg-avatar img { width: 100%; height: 100%; object-fit: cover; }
    .chat-msg-body { flex: 1; min-width: 0; }
    .chat-msg-header { display: flex; align-items: baseline; gap: 8px; margin-bottom: 3px; flex-wrap: wrap; }
    .chat-msg-name { font-weight: 600; font-size: 0.88rem; cursor: pointer; }
    .chat-msg-name:hover { text-decoration: underline; }
    .chat-msg-time { font-size: 0.7rem; color: var(--muted); }
    .chat-msg-text { font-size: 0.88rem; color: #c8cce0; line-height: 1.55; word-break: break-word; }
    .role-badge { display: inline-block; padding: 1px 6px; border-radius: 4px; font-size: 0.65rem; font-weight: 700; margin-right: 4px; vertical-align: middle; }
    .msg-image { max-width: min(320px, 90%); max-height: 220px; border-radius: 10px; margin-top: 6px; cursor: zoom-in; display: block; object-fit: cover; }
    .msg-video { max-width: min(360px, 90%); border-radius: 10px; margin-top: 6px; display: block; }
    .msg-audio { margin-top: 6px; width: min(280px, 90%); }
    .msg-file { display: inline-flex; align-items: center; gap: 10px; background: var(--surface2); border: 1px solid var(--border); border-radius: 10px; padding: 10px 14px; margin-top: 6px; text-decoration: none; color: var(--text); transition: background 0.15s; max-width: min(300px, 90%); }
    .msg-file:hover { background: var(--surface3); }
    .msg-file-icon { font-size: 1.4rem; flex-shrink: 0; }
    .msg-file-name { font-size: 0.82rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 160px; }
    .msg-file-size { font-size: 0.7rem; color: var(--muted); }
    .typing-indicator { padding: 4px 22px 8px; font-size: 0.78rem; color: var(--muted); font-style: italic; min-height: 24px; flex-shrink: 0; }
    .typing-dots { display: inline-flex; gap: 3px; margin-left: 4px; vertical-align: middle; }
    .typing-dots span { width: 4px; height: 4px; border-radius: 50%; background: var(--muted); display: inline-block; animation: typeBounce 1.2s infinite; }
    .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
    .typing-dots span:nth-child(3) { animation-delay: 0.4s; }
    @keyframes typeBounce { 0%,60%,100%{transform:translateY(0)}30%{transform:translateY(-4px)} }
    .upload-progress { display: flex; align-items: center; gap: 10px; padding: 8px 12px; background: var(--surface2); border-radius: 8px; font-size: 0.82rem; color: var(--muted); margin: 4px 8px; }
    .progress-bar { flex: 1; height: 4px; background: var(--surface3); border-radius: 2px; overflow: hidden; }
    .progress-fill { height: 100%; background: var(--accent); border-radius: 2px; transition: width 0.3s; width: 0%; }
    .chat-input-box { display: flex; align-items: center; gap: 8px; background: var(--surface2); border: 1px solid var(--border); border-radius: 12px; padding: 0 12px; transition: border-color 0.2s; }
    .chat-input-box:focus-within { border-color: rgba(91,106,240,0.4); }
    .chat-attach-btn { background: none; border: none; color: var(--muted); cursor: pointer; font-size: 1.2rem; padding: 4px; transition: color 0.2s; flex-shrink: 0; }
    .chat-attach-btn:hover { color: var(--text); }
    .chat-input-box input { flex: 1; background: none; border: none; padding: 13px 0; color: var(--text); font-family: 'DM Sans', sans-serif; font-size: 0.92rem; outline: none; min-width: 0; }
    .chat-input-box input::placeholder { color: var(--muted); }
    .chat-send-btn { background: none; border: none; color: var(--muted); cursor: pointer; font-size: 1.1rem; transition: color 0.2s; flex-shrink: 0; }
    .chat-send-btn:hover { color: var(--accent); }
    .deactivated-bar { padding: 12px 20px; background: rgba(255,95,87,0.08); border-top: 1px solid rgba(255,95,87,0.15); text-align: center; font-size: 0.84rem; color: var(--error); flex-shrink: 0; }
    .no-perm-bar { padding: 12px 20px; background: rgba(124,128,160,0.08); border-top: 1px solid var(--border); text-align: center; font-size: 0.84rem; color: var(--muted); flex-shrink: 0; }

    /* ── SERVER VIEW ── */
    .server-sidebar { display: flex; flex-direction: column; height: 100%; }
    .server-header { padding: 0 14px; height: 52px; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; flex-shrink: 0; font-family: 'Syne', sans-serif; font-weight: 700; font-size: 0.95rem; }
    .server-header-actions { display: flex; gap: 4px; }

    /* ══════════════════════════════
       PROFILE BANNER & EFFECTS
    ══════════════════════════════ */
    .pp-banner {
      height: 100px; flex-shrink: 0; position: relative;
      background: linear-gradient(135deg,#5b6af0,#e040fb);
      overflow: hidden;
    }
    .pp-banner img, .pp-banner video { width:100%; height:100%; object-fit:cover; object-position: var(--banner-pos, 50% 50%); display:block; position:absolute; inset:0; }

    /* ── PROFILE EFFECTS ── */
    /* Sparkle: pseudo CSS floating dots */
    .pp-banner.fx-sparkle::before {
      content:''; position:absolute; inset:0; pointer-events:none;
      background-image: radial-gradient(circle, rgba(255,255,255,0.9) 1px, transparent 1px);
      background-size: 24px 24px;
      animation: sparkleDrift 6s linear infinite;
      opacity: 0.45;
    }
    @keyframes sparkleDrift { 0%{background-position:0 0} 100%{background-position:24px 24px} }

    /* Aurora: sweeping color bands */
    .pp-banner.fx-aurora::after {
      content:''; position:absolute; inset:0; pointer-events:none;
      background: linear-gradient(120deg, transparent 20%, rgba(0,255,200,0.35) 40%, transparent 60%, rgba(120,80,255,0.35) 80%, transparent);
      background-size: 300% 100%;
      animation: auroraWave 4s ease-in-out infinite alternate;
    }
    @keyframes auroraWave { 0%{background-position:0% 50%} 100%{background-position:100% 50%} }

    /* Neon: pulsing glow outline */
    .pp-banner.fx-neon {
      box-shadow: inset 0 0 20px rgba(0,255,180,0.5), inset 0 0 4px rgba(0,255,180,0.8);
      animation: neonPulse 2s ease-in-out infinite alternate;
    }
    @keyframes neonPulse { 0%{box-shadow:inset 0 0 12px rgba(0,255,180,0.4),inset 0 0 4px rgba(0,255,180,0.7)} 100%{box-shadow:inset 0 0 30px rgba(0,255,180,0.7),inset 0 0 8px rgba(0,255,180,1)} }

    /* Holographic: rainbow shimmer */
    .pp-banner.fx-holo::before {
      content:''; position:absolute; inset:0; pointer-events:none;
      background: linear-gradient(105deg, transparent 20%, rgba(255,0,128,0.25) 30%, rgba(255,140,0,0.2) 40%, rgba(0,255,120,0.2) 50%, rgba(0,160,255,0.25) 60%, rgba(180,0,255,0.2) 70%, transparent 80%);
      background-size:200% 100%;
      animation: holoSlide 2.5s linear infinite;
      mix-blend-mode: screen;
    }
    @keyframes holoSlide { 0%{background-position:0% 0} 100%{background-position:200% 0} }

    /* Stars: twinkling dots */
    .pp-banner.fx-stars::before {
      content:'✦ ✧ ✦ ✧ ✦ ✧ ✦ ✧'; position:absolute; inset:0; pointer-events:none;
      color:rgba(255,255,255,0.7); font-size:0.8rem; letter-spacing:10px;
      display:flex; align-items:center; overflow:hidden;
      animation: starBlink 3s ease-in-out infinite alternate;
    }
    @keyframes starBlink { 0%{opacity:0.3;letter-spacing:10px} 100%{opacity:0.9;letter-spacing:14px} }

    /* Fire: rising gradient animation */
    .pp-banner.fx-fire::after {
      content:''; position:absolute; inset:0; pointer-events:none;
      background: linear-gradient(0deg, rgba(255,80,0,0.6) 0%, rgba(255,200,0,0.3) 50%, transparent 100%);
      animation: fireRise 1.5s ease-in-out infinite alternate;
    }
    @keyframes fireRise { 0%{opacity:0.5;transform:scaleY(1)} 100%{opacity:0.9;transform:scaleY(1.08)} }

    /* Ice: frost crystals */
    .pp-banner.fx-ice::before {
      content:''; position:absolute; inset:0; pointer-events:none;
      background: radial-gradient(ellipse at 30% 50%, rgba(180,240,255,0.4) 0%, transparent 60%), radial-gradient(ellipse at 70% 30%, rgba(150,220,255,0.3) 0%, transparent 50%);
      animation: icePulse 3s ease-in-out infinite alternate;
    }
    @keyframes icePulse { 0%{opacity:0.5} 100%{opacity:1} }

    /* Glitch: digital corruption */
    .pp-banner.fx-glitch::before {
      content:''; position:absolute; inset:0; pointer-events:none;
      background: linear-gradient(transparent 0%, rgba(255,0,100,0.15) 25%, transparent 26%, transparent 74%, rgba(0,200,255,0.15) 75%, transparent 100%);
      animation: glitchShift 0.8s steps(2) infinite;
    }
    @keyframes glitchShift { 0%{transform:translateX(0)} 25%{transform:translateX(-3px)} 50%{transform:translateX(2px)} 75%{transform:translateX(-1px)} 100%{transform:translateX(0)} }

    /* ── EFFECT PICKER in modal ── */
    .effect-grid { display:grid; grid-template-columns:repeat(4,1fr); gap:8px; margin-top:6px; }
    .effect-card {
      border-radius:8px; overflow:hidden; cursor:pointer; border:2px solid transparent;
      transition:border-color 0.15s, transform 0.15s; aspect-ratio:2/1;
      position:relative; min-height:42px;
    }
    .effect-card:hover { transform:scale(1.04); }
    .effect-card.selected { border-color:var(--accent); }
    .effect-card-preview { width:100%; height:100%; }
    .effect-card-label { position:absolute; bottom:2px; left:0; right:0; text-align:center; font-size:0.56rem; font-weight:700; color:#fff; text-shadow:0 1px 2px rgba(0,0,0,0.9); letter-spacing:0.03em; text-transform:uppercase; }

    /* ── BANNER CROP MODAL ── */
    #bannerCropModal .modal { max-width:500px; }
    .crop-stage {
      width:100%; aspect-ratio:5/2; background:#111; border-radius:10px;
      overflow:hidden; position:relative; cursor:grab; touch-action:none;
      border:1px solid var(--border);
    }
    .crop-stage:active { cursor:grabbing; }
    .crop-stage img, .crop-stage video { position:absolute; transform-origin:0 0; display:block; max-width:none; }
    .crop-overlay {
      position:absolute; inset:0; pointer-events:none;
      box-shadow: 0 0 0 9999px rgba(0,0,0,0.45);
      border:2px dashed rgba(255,255,255,0.5);
    }
    .crop-hint { font-size:0.76rem; color:var(--muted); text-align:center; margin:8px 0 0; }
    .crop-zoom-row { display:flex; align-items:center; gap:10px; margin-top:10px; }
    .crop-zoom-row label { font-size:0.78rem; color:var(--muted); white-space:nowrap; }
    .crop-zoom-row input[type=range] { flex:1; accent-color:var(--accent); }

    /* ── BANNER SECTION in profile modal ── */
    .banner-upload-area {
      width:100%; aspect-ratio:5/2; border-radius:10px; overflow:hidden;
      background:linear-gradient(135deg,#5b6af0,#e040fb);
      position:relative; cursor:pointer; margin-bottom:16px;
      border:1px solid var(--border);
    }
    .banner-upload-area img, .banner-upload-area video {
      width:100%; height:100%; object-fit:cover;
      object-position: var(--banner-pos, 50% 50%);
    }
    .banner-upload-overlay {
      position:absolute; inset:0; background:rgba(0,0,0,0); display:flex;
      align-items:center; justify-content:center; gap:8px;
      transition:background 0.2s;
    }
    .banner-upload-area:hover .banner-upload-overlay { background:rgba(0,0,0,0.45); }
    .banner-upload-btn {
      background:rgba(255,255,255,0.15); backdrop-filter:blur(4px);
      border:1px solid rgba(255,255,255,0.3); color:#fff; border-radius:8px;
      padding:7px 14px; font-size:0.8rem; font-weight:600; cursor:pointer;
      font-family:'DM Sans',sans-serif; opacity:0; transition:opacity 0.2s;
    }
    .banner-upload-area:hover .banner-upload-btn { opacity:1; }


    .dash-report-chip { padding:5px 13px;border-radius:100px;border:1px solid var(--border2);background:var(--surface2);color:var(--text);font-family:'DM Sans',sans-serif;font-size:0.82rem;cursor:pointer;transition:all .15s; }
    .dash-report-chip.selected { background:rgba(229,57,53,0.18);border-color:#e53935;color:#ff8a80; }

    /* ── RIGHT PROFILE PANEL ── */
    .profile-panel { width: 260px; background: var(--surface); border-left: 1px solid var(--border); flex-shrink: 0; display: flex; flex-direction: column; overflow: hidden; transition: width 0.25s; position: relative; }
    .profile-panel.hidden { width: 0; overflow: hidden; border: none; }
    .pp-close-btn { position: absolute; top: 8px; right: 8px; background: rgba(0,0,0,0.3); border: none; color: #fff; width: 24px; height: 24px; border-radius: 50%; cursor: pointer; font-size: 0.9rem; display: flex; align-items: center; justify-content: center; z-index:2; }
    /* Avatar shelf: sits between banner and body as a flex child, NOT overflow-y clipped */
    /* Avatar shelf: absolutely positioned so overflow-y:auto on pp-body never clips it */
    .pp-avatar-shelf { position: absolute; top: 76px; left: 16px; z-index: 10; pointer-events: none; }
    .pp-body { padding: 44px 16px 24px; position: relative; z-index: 1; flex: 1; overflow-y: auto; }
    .pp-avatar-wrap { position: relative; display: inline-block; pointer-events: all; }
    .pp-avatar { width: 64px; height: 64px; border-radius: 50%; border: 4px solid var(--surface); display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 1.3rem; color: #fff; overflow: hidden; box-shadow: 0 2px 12px rgba(0,0,0,0.5); }
    .pp-avatar img { width: 100%; height: 100%; object-fit: cover; }
    .pp-status-badge { position: absolute; bottom: 3px; right: 3px; width: 17px; height: 17px; border-radius: 50%; border: 3px solid var(--surface); z-index: 4; }
    .pp-status-line { font-size: 0.82rem; color: var(--muted); margin-bottom: 14px; display: flex; align-items: center; gap: 6px; }
    .pp-section-title { font-size: 0.7rem; font-weight: 700; letter-spacing: 0.08em; text-transform: uppercase; color: var(--muted); margin-bottom: 6px; }
    .pp-bio { font-size: 0.85rem; color: #c8cce0; line-height: 1.6; white-space: pre-wrap; word-break: break-word; }
    .pp-username { font-size: 0.8rem; color: var(--muted); margin-bottom: 6px; }
    .pp-divider { height: 1px; background: var(--border); margin: 12px 0; }
    .pp-since { font-size: 0.82rem; color: var(--muted); }
    .pp-dm-btn { width: 100%; margin-top: 16px; padding: 10px; background: var(--accent); color: #fff; border: none; border-radius: 8px; font-family: 'DM Sans', sans-serif; font-size: 0.88rem; font-weight: 600; cursor: pointer; transition: background 0.2s; }
    .pp-dm-btn:hover { background: #6b7af8; }
    .pp-feed-btn { width: 100%; margin-top: 8px; padding: 10px; background: transparent; color: var(--muted); border: 1px solid var(--border); border-radius: 8px; font-family: 'DM Sans', sans-serif; font-size: 0.88rem; font-weight: 600; cursor: pointer; transition: all 0.2s; }
    .pp-feed-btn:hover { background: var(--surface2); color: var(--text); border-color: var(--accent); }

    /* ── PROFILE PANEL FULL EFFECTS ── */
    /* Canvas layer for JS particle effects */
    .pp-effect-canvas { position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:0; border-radius:inherit; }

    /* Overlay effect layers — applied inside pp-body so the avatar bubble isn't clipped */
    .profile-panel { position:relative; }
    .profile-panel.pfx-sparkle .pp-body,
    .profile-panel.pfx-aurora .pp-body,
    .profile-panel.pfx-neon .pp-body,
    .profile-panel.pfx-holo .pp-body,
    .profile-panel.pfx-stars .pp-body,
    .profile-panel.pfx-fire .pp-body,
    .profile-panel.pfx-ice .pp-body,
    .profile-panel.pfx-glitch .pp-body { overflow: hidden; }

    /* Sparkle: twinkling star grid on body */
    .profile-panel.pfx-sparkle .pp-body::before {
      content:''; position:absolute; inset:-20px; pointer-events:none; z-index:0;
      background-image: radial-gradient(circle, rgba(255,255,255,0.85) 1px, transparent 1px);
      background-size: 20px 20px;
      animation: ppSparkleDrift 8s linear infinite;
      opacity: 0.18;
    }
    @keyframes ppSparkleDrift { 0%{transform:translate(0,0)} 100%{transform:translate(20px,20px)} }

    /* Aurora: sweeping color bands across whole panel */
    .profile-panel.pfx-aurora::after {
      content:''; position:absolute; inset:0; pointer-events:none; z-index:0;
      background: linear-gradient(160deg, transparent 15%, rgba(0,255,180,0.06) 35%, transparent 55%, rgba(100,60,255,0.07) 75%, transparent);
      background-size: 300% 300%;
      animation: ppAurora 6s ease-in-out infinite alternate;
    }
    @keyframes ppAurora { 0%{background-position:0% 0%} 100%{background-position:100% 100%} }

    /* Neon: colored border glow on the panel */
    .profile-panel.pfx-neon {
      box-shadow: inset 2px 0 30px rgba(0,255,180,0.08), -1px 0 0 rgba(0,255,180,0.25);
      animation: ppNeon 2.5s ease-in-out infinite alternate;
    }
    @keyframes ppNeon { 0%{box-shadow:inset 2px 0 20px rgba(0,255,180,0.06),-1px 0 0 rgba(0,255,180,0.15)} 100%{box-shadow:inset 2px 0 40px rgba(0,255,180,0.14),-1px 0 0 rgba(0,255,180,0.5)} }

    /* Holo: diagonal rainbow shimmer across whole panel */
    .profile-panel.pfx-holo::after {
      content:''; position:absolute; inset:0; pointer-events:none; z-index:0;
      background: linear-gradient(115deg, transparent 20%, rgba(255,0,128,0.07) 30%, rgba(255,180,0,0.06) 40%, rgba(0,255,120,0.07) 50%, rgba(0,140,255,0.07) 60%, rgba(180,0,255,0.06) 70%, transparent 80%);
      background-size: 200% 100%;
      animation: ppHolo 3s linear infinite;
      mix-blend-mode: screen;
    }
    @keyframes ppHolo { 0%{background-position:0% 0} 100%{background-position:200% 0} }

    /* Stars: text stars float upward via JS canvas — CSS sets dark bg tint */
    .profile-panel.pfx-stars::after {
      content:''; position:absolute; inset:0; pointer-events:none; z-index:0;
      background: radial-gradient(ellipse at 50% 30%, rgba(20,20,60,0.3) 0%, transparent 70%);
    }

    /* Fire: orange glow rising from bottom */
    .profile-panel.pfx-fire::after {
      content:''; position:absolute; inset:0; pointer-events:none; z-index:0;
      background: linear-gradient(0deg, rgba(255,70,0,0.12) 0%, rgba(255,160,0,0.05) 40%, transparent 70%);
      animation: ppFire 2s ease-in-out infinite alternate;
    }
    @keyframes ppFire { 0%{opacity:0.6;transform:scaleY(1)} 100%{opacity:1;transform:scaleY(1.04)} }

    /* Ice: frost bloom from corners */
    .profile-panel.pfx-ice::after {
      content:''; position:absolute; inset:0; pointer-events:none; z-index:0;
      background: radial-gradient(ellipse at 0% 0%, rgba(150,220,255,0.1) 0%, transparent 50%), radial-gradient(ellipse at 100% 100%, rgba(180,230,255,0.08) 0%, transparent 50%);
      animation: ppIce 4s ease-in-out infinite alternate;
    }
    @keyframes ppIce { 0%{opacity:0.5} 100%{opacity:1} }

    /* Glitch: scan-line shift on panel */
    .profile-panel.pfx-glitch::after {
      content:''; position:absolute; inset:0; pointer-events:none; z-index:0;
      background: repeating-linear-gradient(0deg, transparent 0px, transparent 3px, rgba(255,0,120,0.02) 3px, rgba(255,0,120,0.02) 4px);
      animation: ppGlitch 0.7s steps(3) infinite;
    }
    @keyframes ppGlitch { 0%{transform:translateX(0)} 33%{transform:translateX(-2px)} 66%{transform:translateX(2px)} 100%{transform:translateX(0)} }

    /* Name glow per effect */
    .profile-panel.pfx-neon .pp-name    { text-shadow: 0 0 8px rgba(0,255,180,0.6), 0 0 20px rgba(0,255,180,0.3); }
    .profile-panel.pfx-fire .pp-name    { text-shadow: 0 0 8px rgba(255,120,0,0.7), 0 0 20px rgba(255,80,0,0.4); }
    .profile-panel.pfx-ice .pp-name     { text-shadow: 0 0 8px rgba(160,230,255,0.7), 0 0 20px rgba(120,200,255,0.4); }
    .profile-panel.pfx-holo .pp-name    { text-shadow: 0 0 10px rgba(180,100,255,0.5), 0 0 20px rgba(100,180,255,0.3); }
    .profile-panel.pfx-glitch .pp-name  { text-shadow: 2px 0 rgba(255,0,100,0.4), -2px 0 rgba(0,200,255,0.4); animation: ppGlitch 0.7s steps(3) infinite; }
    .profile-panel.pfx-aurora .pp-name  { text-shadow: 0 0 12px rgba(0,220,160,0.5); }
    .profile-panel.pfx-sparkle .pp-name { text-shadow: 0 0 6px rgba(200,180,255,0.6); }

    /* Mobile sheet effect support */
    .mobile-profile-sheet-inner { position:relative; overflow:hidden; }
    .mobile-profile-sheet-inner::after { content:''; position:absolute; inset:0; pointer-events:none; z-index:0; }
    

    /* ── ADMIN PANEL ── */
    .admin-toolbar { display: flex; align-items: center; gap: 10px; padding: 16px 20px; border-bottom: 1px solid var(--border); flex-wrap: wrap; }
    .admin-search { flex: 1; min-width: 160px; background: var(--surface2); border: 1px solid var(--border); border-radius: 8px; padding: 9px 12px; color: var(--text); font-family: 'DM Sans', sans-serif; font-size: 0.85rem; outline: none; }
    .admin-search:focus { border-color: var(--admin); }
    .admin-search::placeholder { color: var(--muted); }
    .admin-filter { padding: 9px 12px; background: var(--surface2); border: 1px solid var(--border); border-radius: 8px; color: var(--text); font-family: 'DM Sans', sans-serif; font-size: 0.82rem; outline: none; cursor: pointer; }
    .admin-stats { display: grid; grid-template-columns: repeat(4,1fr); gap: 10px; padding: 14px 20px; border-bottom: 1px solid var(--border); }
    .admin-stat { background: var(--surface2); border: 1px solid var(--border); border-radius: 10px; padding: 12px 14px; }
    .admin-stat-num { font-family: 'Syne', sans-serif; font-weight: 800; font-size: 1.4rem; margin-bottom: 2px; }
    .admin-stat-label { font-size: 0.72rem; color: var(--muted); }
    .admin-table { flex: 1; overflow-y: auto; }
    .admin-table-header { display: grid; grid-template-columns: 2fr 1.5fr 0.8fr 0.8fr 1.4fr; padding: 8px 20px; font-size: 0.7rem; font-weight: 700; letter-spacing: 0.06em; text-transform: uppercase; color: var(--muted); border-bottom: 1px solid var(--border); }
    .admin-user-row { display: grid; grid-template-columns: 2fr 1.5fr 0.8fr 0.8fr 1.4fr; align-items: center; padding: 10px 20px; border-bottom: 1px solid var(--border); transition: background 0.15s; gap: 8px; }
    .admin-user-row:hover { background: var(--surface2); }
    .admin-user-info { display: flex; align-items: center; gap: 8px; min-width: 0; }
    .admin-avatar { width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.78rem; color: #fff; flex-shrink: 0; overflow: hidden; }
    .admin-avatar img { width: 100%; height: 100%; object-fit: cover; }
    .admin-user-name { font-weight: 600; font-size: 0.85rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .admin-user-tag { font-size: 0.72rem; color: var(--muted); }
    .admin-badge { display: inline-flex; align-items: center; padding: 2px 7px; border-radius: 20px; font-size: 0.7rem; font-weight: 600; }
    .badge-active { background: rgba(35,209,139,0.12); color: var(--success); }
    .badge-banned { background: rgba(255,95,87,0.12); color: var(--error); }
    .badge-warned { background: rgba(255,167,38,0.12); color: var(--idle); }
    .badge-deleted { background: rgba(124,128,160,0.12); color: var(--muted); }
    .badge-temp { background: rgba(245,158,11,0.12); color: var(--admin); }
    .admin-actions { display: flex; gap: 4px; flex-wrap: wrap; }
    .admin-btn { padding: 4px 8px; border-radius: 5px; font-family: 'DM Sans', sans-serif; font-size: 0.72rem; font-weight: 600; cursor: pointer; border: none; transition: all 0.15s; }
    .admin-btn-warn { background: rgba(255,167,38,0.15); color: var(--idle); }
    .admin-btn-warn:hover { background: rgba(255,167,38,0.3); }
    .admin-btn-temp { background: rgba(245,158,11,0.15); color: var(--admin); }
    .admin-btn-temp:hover { background: rgba(245,158,11,0.3); }
    .admin-btn-ban { background: rgba(255,95,87,0.15); color: var(--error); }
    .admin-btn-ban:hover { background: rgba(255,95,87,0.3); }
    .admin-btn-unban { background: rgba(35,209,139,0.15); color: var(--success); }
    .admin-btn-unban:hover { background: rgba(35,209,139,0.3); }
    .admin-btn-delete { background: rgba(124,128,160,0.1); color: var(--muted); }
    .admin-btn-delete:hover { background: rgba(255,95,87,0.15); color: var(--error); }
    .admin-empty { padding: 40px; text-align: center; color: var(--muted); font-size: 0.88rem; }

    /* ── MODALS ── */
    .modal-overlay { position: fixed; inset: 0; z-index: 999; background: rgba(0,0,0,0.75); backdrop-filter: blur(8px); display: flex; align-items: center; justify-content: center; padding: 16px; opacity: 0; pointer-events: none; transition: opacity 0.2s; }
    .modal-overlay.open { opacity: 1; pointer-events: all; }
    .modal { background: var(--surface); border: 1px solid var(--border); border-radius: 20px; padding: 32px 28px; width: 100%; max-width: 460px; position: relative; transform: translateY(16px); transition: transform 0.2s; max-height: calc(100vh - 32px); overflow-y: auto; }
    .modal-overlay.open .modal { transform: translateY(0); }
    .modal-close { position: absolute; top: 14px; right: 16px; background: none; border: none; color: var(--muted); font-size: 1.4rem; cursor: pointer; }
    .modal-close:hover { color: var(--text); }
    .modal h2 { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 1.3rem; margin-bottom: 6px; }
    .modal > p, .modal-desc { color: var(--muted); font-size: 0.86rem; margin-bottom: 22px; }
    .form-group { display: flex; flex-direction: column; gap: 6px; margin-bottom: 14px; }
    .form-group label { font-size: 0.75rem; font-weight: 700; color: var(--muted); letter-spacing: 0.06em; text-transform: uppercase; }
    .form-group input, .form-group textarea, .form-group select { background: var(--surface2); border: 1px solid var(--border); border-radius: 8px; padding: 11px 13px; color: var(--text); font-family: 'DM Sans', sans-serif; font-size: 0.9rem; outline: none; transition: border-color 0.2s; resize: none; width: 100%; }
    .form-group input:focus, .form-group textarea:focus, .form-group select:focus { border-color: var(--accent); }
    .form-group input::placeholder, .form-group textarea::placeholder { color: #4a4f6a; }
    .form-group input:disabled { opacity: 0.5; cursor: not-allowed; }
    .modal-btn { width: 100%; padding: 12px; background: var(--accent); color: #fff; border: none; border-radius: 8px; font-family: 'DM Sans', sans-serif; font-size: 0.9rem; font-weight: 600; cursor: pointer; transition: background 0.2s; box-shadow: 0 0 20px var(--glow); }
    .modal-btn:hover { background: #6b7af8; }
    .modal-btn.danger { background: var(--error); box-shadow: none; }
    .modal-btn.danger:hover { background: #e04040; }
    .modal-btn.secondary { background: var(--surface2); color: var(--text); box-shadow: none; }
    .modal-btn.secondary:hover { background: var(--surface3); }
    .modal-btn-row { display: flex; gap: 10px; }
    .modal-btn-row .modal-btn { flex: 1; }
    .avatar-upload-area { display: flex; align-items: center; gap: 16px; margin-bottom: 20px; }
    .avatar-preview { width: 72px; height: 72px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 1.6rem; color: #fff; flex-shrink: 0; overflow: hidden; border: 3px solid var(--border); }
    .avatar-preview img { width: 100%; height: 100%; object-fit: cover; }
    .avatar-upload-btns { display: flex; flex-direction: column; gap: 6px; }
    .avatar-upload-btns button { padding: 7px 14px; border-radius: 8px; font-family: 'DM Sans', sans-serif; font-size: 0.8rem; font-weight: 600; cursor: pointer; border: none; }
    .upload-btn { background: var(--accent); color: #fff; }
    .remove-btn { background: var(--surface2); color: var(--muted); }
    .avatar-upload-btns p { font-size: 0.72rem; color: var(--muted); }
    .status-selector { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 18px; }
    .status-option { display: flex; align-items: center; gap: 8px; padding: 9px 12px; background: var(--surface2); border: 2px solid var(--border); border-radius: 10px; cursor: pointer; transition: all 0.15s; font-size: 0.83rem; }
    .status-option:hover { border-color: rgba(255,255,255,0.15); }
    .status-option.selected { border-color: var(--accent); background: rgba(91,106,240,0.1); }
    .status-pip { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
    .server-type-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 18px; }
    .server-type-card { background: var(--surface2); border: 2px solid var(--border); border-radius: 10px; padding: 14px; cursor: pointer; transition: all 0.2s; text-align: center; }
    .server-type-card:hover, .server-type-card.selected { border-color: var(--accent); background: rgba(91,106,240,0.08); }
    .server-type-card .type-icon { font-size: 1.6rem; margin-bottom: 6px; }
    .server-type-card .type-name { font-size: 0.8rem; font-weight: 600; }
    .call-display { text-align: center; padding: 20px 0; }
    .call-avatar { width: 80px; height: 80px; border-radius: 50%; margin: 0 auto 14px; display: flex; align-items: center; justify-content: center; font-size: 2rem; font-weight: 700; color: #fff; overflow: hidden; animation: callPulse 2s infinite; }
    .call-avatar img { width: 100%; height: 100%; object-fit: cover; }
    @keyframes callPulse { 0%,100%{box-shadow:0 0 0 0 rgba(91,106,240,0.4)}50%{box-shadow:0 0 0 14px rgba(91,106,240,0)} }
    .call-name { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 1.2rem; margin-bottom: 5px; }
    .call-status { color: var(--muted); font-size: 0.86rem; margin-bottom: 24px; }
    .call-actions { display: flex; justify-content: center; gap: 16px; }
    .call-action-btn { width: 52px; height: 52px; border-radius: 50%; border: none; cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; transition: transform 0.15s; }
    .call-action-btn:hover { transform: scale(1.1); }
    .call-action-btn.end { background: var(--error); color: #fff; }
    .call-action-btn.mute, .call-action-btn.video { background: var(--surface2); color: var(--text); }
    .danger-zone { border: 1px solid rgba(255,95,87,0.2); border-radius: 12px; padding: 18px; margin-top: 8px; }
    .danger-zone h4 { font-family: 'Syne', sans-serif; font-weight: 700; color: var(--error); margin-bottom: 8px; font-size: 0.92rem; }
    .danger-zone p { color: var(--muted); font-size: 0.8rem; margin-bottom: 14px; line-height: 1.5; }
    /* invite link display */
    .invite-link-box { display: flex; align-items: center; gap: 8px; background: var(--surface2); border: 1px solid var(--border); border-radius: 8px; padding: 10px 14px; margin: 14px 0; }
    .invite-link-box span { flex: 1; font-size: 0.82rem; color: var(--text); word-break: break-all; }
    .copy-btn { padding: 6px 12px; background: var(--accent); color: #fff; border: none; border-radius: 6px; font-family: 'DM Sans', sans-serif; font-size: 0.78rem; font-weight: 600; cursor: pointer; flex-shrink: 0; }
    /* roles list */
    .role-row { display: flex; align-items: center; gap: 10px; padding: 8px 0; border-bottom: 1px solid var(--border); }
    .role-color-dot { width: 14px; height: 14px; border-radius: 50%; flex-shrink: 0; }
    .role-name { flex: 1; font-size: 0.88rem; font-weight: 600; }
    .role-perms { font-size: 0.72rem; color: var(--muted); }
    .role-del-btn { background: none; border: none; color: var(--muted); cursor: pointer; font-size: 0.9rem; padding: 2px 6px; border-radius: 4px; }
    .role-del-btn:hover { background: rgba(255,95,87,0.15); color: var(--error); }
    .perm-toggle { display: flex; align-items: center; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border); font-size: 0.86rem; }
    .perm-toggle:last-child { border: none; }
    .toggle-switch { position: relative; width: 36px; height: 20px; flex-shrink: 0; }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .toggle-slider { position: absolute; inset: 0; background: var(--surface3); border-radius: 20px; cursor: pointer; transition: background 0.2s; }
    .toggle-slider::before { content:''; position: absolute; width: 14px; height: 14px; left: 3px; top: 3px; background: #fff; border-radius: 50%; transition: transform 0.2s; }
    .toggle-switch input:checked + .toggle-slider { background: var(--accent); }
    .toggle-switch input:checked + .toggle-slider::before { transform: translateX(16px); }
    /* member rows in roles modal */
    .member-row { display: flex; align-items: center; gap: 10px; padding: 8px 0; border-bottom: 1px solid var(--border); }
    .member-row:last-child { border: none; }
    .member-row .member-info { flex: 1; min-width: 0; }
    .member-row .member-name { font-size: 0.88rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .member-row .member-tag { font-size: 0.72rem; color: var(--muted); }
    .member-role-select { background: var(--surface2); border: 1px solid var(--border); border-radius: 6px; padding: 5px 8px; color: var(--text); font-family: 'DM Sans', sans-serif; font-size: 0.78rem; outline: none; cursor: pointer; }

    /* misc */
    .pending-badge { background: var(--error); color: #fff; font-size: 0.62rem; font-weight: 700; border-radius: 10px; padding: 1px 5px; }
    .request-row { display: flex; align-items: center; gap: 10px; padding: 10px 14px; border-bottom: 1px solid var(--border); }
    .request-actions { margin-left: auto; display: flex; gap: 6px; }
    .req-btn { padding: 5px 12px; border-radius: 6px; font-family: 'DM Sans', sans-serif; font-size: 0.78rem; font-weight: 600; cursor: pointer; border: none; }
    .req-btn.accept { background: var(--success); color: #fff; }
    .req-btn.decline { background: var(--surface2); color: var(--muted); }
    .add-result { font-size: 0.86rem; padding: 9px 12px; border-radius: 8px; display: none; margin-bottom: 10px; }
    .add-result.success { background: rgba(35,209,139,0.1); color: var(--success); border: 1px solid rgba(35,209,139,0.2); display: block; }
    .add-result.error { background: rgba(255,95,87,0.1); color: var(--error); border: 1px solid rgba(255,95,87,0.2); display: block; }
    .empty-state { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; text-align: center; gap: 14px; padding: 24px; }
    .empty-state .empty-icon { font-size: 3.5rem; }
    .empty-state h3 { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 1.2rem; }
    .empty-state p { color: var(--muted); font-size: 0.88rem; max-width: 300px; line-height: 1.6; }
    .lightbox { position: fixed; inset: 0; z-index: 9998; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; cursor: zoom-out; opacity: 0; pointer-events: none; transition: opacity 0.2s; }
    .lightbox.open { opacity: 1; pointer-events: all; }
    .lightbox img { max-width: 92vw; max-height: 90vh; border-radius: 10px; object-fit: contain; }
    .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%) translateY(20px); background: var(--surface2); border: 1px solid var(--border); border-radius: 10px; padding: 11px 18px; font-size: 0.86rem; color: var(--text); z-index: 9999; opacity: 0; transition: all 0.3s; pointer-events: none; white-space: nowrap; max-width: 90vw; }
    .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
    .toast.success { border-color: rgba(35,209,139,0.3); color: var(--success); }
    .toast.error { border-color: rgba(255,95,87,0.3); color: var(--error); }

    /* Hide mobile nav on desktop */
    .mobile-nav { display: none; }

    /* ════════════════════════════════
       MOBILE LAYOUT  ≤ 680px
    ════════════════════════════════ */
    @media (max-width: 680px) {
      body { flex-direction: column; overflow: hidden; }
      .servers-bar { display: none; }
      /* Sidebar slides in from left, sits above everything */
      .sidebar {
        position: fixed; top: 0; left: 0;
        bottom: var(--mobile-nav-h); width: 80vw; max-width: 300px;
        z-index: 200; transform: translateX(-100%); box-shadow: 4px 0 24px rgba(0,0,0,0.5);
        transition: transform 0.3s;
      }
      .sidebar.open { transform: translateX(0); }
      .sidebar-overlay { display: none; position: fixed; inset: 0; bottom: var(--mobile-nav-h); background: rgba(0,0,0,0.5); z-index: 199; }
      .sidebar-overlay.open { display: block; }
      .profile-panel { display: none; }
      /* Main fills from top to just above mobile nav */
      .main {
        position: fixed;
        top: 0; left: 0; right: 0;
        bottom: var(--mobile-nav-h);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      /* Header always 52px */
      .main-header { flex-shrink: 0; }
      /* main-content fills remainder */
      .main-content { flex: 1; min-height: 0; overflow-y: auto; }
      .main-content.chat-mode { overflow: hidden; display: flex; flex-direction: column; }
      /* chat-view fills chat-mode exactly */
      .chat-view { flex: 1; display: flex; flex-direction: column; min-height: 0; overflow: hidden; }
      .chat-messages { flex: 1; min-height: 0; overflow-y: auto; }
      /* Input box anchored at bottom, never hidden */
      .chat-input-area {
        flex-shrink: 0;
        padding: 8px 10px 10px;
        background: var(--bg);
      }
      .hamburger { display: flex; }
      /* bottom nav */
      .mobile-nav {
        position: fixed; bottom: 0; left: 0; right: 0; height: var(--mobile-nav-h);
        background: var(--surface); border-top: 1px solid var(--border);
        display: flex; align-items: center; justify-content: space-around;
        z-index: 300; padding: 0 4px;
      }
      .mobile-nav-btn {
        display: flex; flex-direction: column; align-items: center; gap: 3px;
        background: none; border: none; color: var(--muted); cursor: pointer;
        font-size: 1.3rem; padding: 6px 8px; border-radius: 10px; transition: color 0.15s;
        flex: 1;
      }
      .mobile-nav-btn span { font-size: 0.56rem; font-weight: 700; letter-spacing: 0.03em; text-transform: uppercase; }
      .mobile-nav-btn.active { color: var(--accent); }
      .mobile-nav-badge { position: relative; }
      .mobile-nav-badge::after { content: attr(data-badge); position: absolute; top: -4px; right: -6px; background: var(--error); color: #fff; font-size: 0.55rem; font-weight: 700; border-radius: 10px; padding: 1px 4px; display: none; }
      .mobile-nav-badge[data-badge]:not([data-badge=""])::after { display: block; }
      .admin-stats { grid-template-columns: 1fr 1fr; }
      .admin-table-header { display: none; }
      .admin-user-row { grid-template-columns: 1fr auto; grid-template-rows: auto auto; gap: 4px; }
      .admin-user-row > div:nth-child(2), .admin-user-row > div:nth-child(3) { display: none; }
      .header-tabs { overflow-x: auto; -webkit-overflow-scrolling: touch; }
      .header-tabs::-webkit-scrollbar { display: none; }
    }


    /* ── ACTIVE CALL PIP (bottom-right corner) ── */
    .call-pip {
      position: fixed; bottom: 80px; right: 20px; z-index: 8000;
      background: var(--surface); border: 1px solid #23d18b;
      border-radius: 16px; padding: 12px 16px;
      display: none; align-items: center; gap: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      cursor: pointer; transition: transform 0.2s;
      min-width: 200px;
    }
    .call-pip:hover { transform: scale(1.02); }
    .call-pip.visible { display: flex; }
    .call-pip-avatars { display: flex; }
    .call-pip-av { width: 32px; height: 32px; border-radius: 50%; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:0.8rem; color:#fff; overflow:hidden; border:2px solid var(--surface); flex-shrink:0; }
    .call-pip-av + .call-pip-av { margin-left:-8px; }
    .call-pip-info { flex:1; min-width:0; }
    .call-pip-title { font-size:0.82rem; font-weight:700; color:#23d18b; }
    .call-pip-sub { font-size:0.72rem; color:var(--muted); }
    .call-pip-end { background:var(--error); border:none; color:#fff; border-radius:8px; padding:5px 10px; font-size:0.75rem; font-weight:700; cursor:pointer; white-space:nowrap; }
    @media (max-width:680px) { .call-pip { bottom: calc(var(--mobile-nav-h) + 12px); right:12px; } }
    /* Hide screen share on mobile — getDisplayMedia not supported */
    @media (max-width:680px) { #screenshare-btn { display: none !important; } }

    /* ── GROUP CHAT ── */
    .gc-badge { background:rgba(91,106,240,0.2); border:1px solid rgba(91,106,240,0.3); border-radius:4px; font-size:0.64rem; font-weight:700; padding:1px 5px; color:var(--accent); margin-left:4px; }
    .gc-members-grid { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
    .gc-member-chip { display:flex; align-items:center; gap:6px; background:var(--surface2); border:1px solid var(--border); border-radius:20px; padding:5px 10px; font-size:0.82rem; cursor:pointer; transition:border-color 0.15s; }
    .gc-member-chip.selected { border-color:var(--accent); background:rgba(91,106,240,0.12); }
    .gc-member-chip .chip-av { width:22px; height:22px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:0.62rem; color:#fff; overflow:hidden; }

    /* ── VOICE CHANNEL ── */
    .voice-channel-item { display:flex; align-items:center; gap:8px; padding:6px 12px; border-radius:6px; margin:1px 8px; cursor:pointer; transition:background 0.15s; font-size:0.88rem; color:var(--muted); }
    .voice-channel-item:hover { background:var(--surface2); color:var(--text); }
    .voice-channel-item.in-call { color:#23d18b; }
    .voice-participants { padding:0 8px 4px 32px; display:flex; flex-direction:column; gap:2px; }
    .voice-participant { font-size:0.78rem; color:var(--muted); display:flex; align-items:center; gap:6px; }
    .voice-participant .vp-av { width:18px; height:18px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:0.55rem; color:#fff; overflow:hidden; flex-shrink:0; }

    /* ── CALL MODAL expanded for group ── */
    .call-participants-row { display:flex; flex-wrap:wrap; gap:8px; justify-content:center; max-width:300px; }
    .call-part-av { width:56px; height:56px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:1.2rem; color:#fff; overflow:hidden; border:3px solid var(--surface); position:relative; }
    .call-part-av .speaking-ring { position:absolute; inset:-3px; border-radius:50%; border:3px solid #23d18b; opacity:0; transition:opacity 0.2s; }
    .call-part-av.speaking .speaking-ring { opacity:1; animation:speakPulse 1s infinite; }
    @keyframes speakPulse { 0%,100%{opacity:0.6} 50%{opacity:1} }

    /* ── WEBRTC audio elements ── */
    .remote-audio { display:none; }

    /* ── SCREEN SHARE ── */
    .call-modal-inner { position: relative; }
    .screenshare-view {
      width: 100%; border-radius: 10px; overflow: hidden;
      background: #000; position: relative;
      display: none; flex-direction: column; gap: 0;
    }
    .screenshare-view.visible { display: flex; }
    .screenshare-video {
      width: 100%; max-height: 52vh; object-fit: contain;
      background: #000; border-radius: 10px 10px 0 0; display: block;
    }
    .screenshare-label {
      background: rgba(0,0,0,0.7); padding: 6px 12px;
      font-size: 0.76rem; color: #23d18b; display: flex; align-items: center; gap: 6px;
      border-radius: 0 0 10px 10px;
    }
    .screenshare-label::before { content: ''; width: 8px; height: 8px; border-radius: 50%; background: #23d18b; display: inline-block; animation: pulse 1.5s infinite; }
    .screenshare-pip {
      position: absolute; bottom: 8px; right: 8px;
      width: 80px; height: 60px; border-radius: 6px; overflow: hidden;
      border: 2px solid rgba(255,255,255,0.3); background: #111; display: none;
    }
    .screenshare-pip video { width: 100%; height: 100%; object-fit: cover; }
    .call-modal-inner.sharing .screenshare-view { display: flex; }
    /* Expand modal when sharing */
    #callModal .modal { max-width: min(92vw, 820px) !important; }
    .call-share-btn { background: var(--surface2); border: 1px solid var(--border); color: var(--text); border-radius: 8px; padding: 10px 18px; font-family: 'DM Sans', sans-serif; font-size: 0.85rem; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 6px; }
    .call-share-btn:hover { border-color: var(--accent); color: var(--accent); }
    .call-share-btn.active { background: rgba(35,209,139,0.12); border-color: #23d18b; color: #23d18b; }
    .call-controls { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; margin-top: 4px; }

    /* ── MESSAGE REACTIONS ── */
    .msg-reactions { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 5px; }
    .reaction-pill { display: inline-flex; align-items: center; gap: 4px; background: var(--surface2); border: 1px solid var(--border); border-radius: 100px; padding: 2px 8px; font-size: 0.78rem; cursor: pointer; transition: all 0.15s; user-select: none; }
    .reaction-pill:hover { border-color: var(--accent); background: rgba(91,106,240,0.1); }
    .reaction-pill.reacted { border-color: var(--accent); background: rgba(91,106,240,0.15); color: var(--accent); }
    .reaction-pill .r-count { font-weight: 600; }
    .reaction-picker { position: absolute; right: 8px; top: -32px; background: var(--surface); border: 1px solid var(--border); border-radius: 10px; padding: 5px 8px; display: none; gap: 4px; z-index: 20; box-shadow: 0 4px 16px rgba(0,0,0,0.4); }
    .chat-msg:hover .reaction-picker { display: flex; }
    .reaction-emoji { cursor: pointer; font-size: 1.1rem; padding: 2px 4px; border-radius: 5px; transition: background 0.1s; }
    .reaction-emoji:hover { background: var(--surface2); }

    /* ── UNREAD BADGE on sidebar DMs ── */
    .sidebar-item { position: relative; }
    .unread-dot { position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: var(--error); border-radius: 50%; width: 8px; height: 8px; display: none; }
    .sidebar-item.unread .unread-dot { display: block; }

    /* ── TYPING bold ── */
    .typing-indicator strong { color:var(--text); }

    /* ── SIDEBAR voice-ch label ── */
    .sidebar-section-label.vc-label { cursor:default; }

    /* ── NEW GROUP CHAT button ── */
    .new-gc-btn { background:none; border:1px solid var(--border); border-radius:6px; padding:4px 8px; color:var(--muted); cursor:pointer; font-size:0.78rem; font-family:'DM Sans',sans-serif; transition:all 0.15s; }
    .new-gc-btn:hover { color:var(--text); border-color:var(--accent); }

    /* ── SEPARATOR ── */
        /* ── INCOMING CALL BANNER ── */
    .incoming-call-bar {
      position: fixed; top: 0; left: 0; right: 0; z-index: 9000;
      background: linear-gradient(135deg, #1c2a1c, #1a2a1a);
      border-bottom: 2px solid #23d18b;
      display: flex; align-items: center; gap: 14px;
      padding: 14px 24px;
      transform: translateY(-100%);
      transition: transform 0.35s cubic-bezier(0.34,1.56,0.64,1);
      box-shadow: 0 4px 32px rgba(0,0,0,0.6);
    }
    .incoming-call-bar.visible { transform: translateY(0); }
    .incoming-call-bar .ic-avatars { display: flex; align-items: center; }
    .incoming-call-bar .ic-av { width: 42px; height: 42px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 1rem; color: #fff; overflow: hidden; border: 2px solid #13151c; flex-shrink: 0; }
    .incoming-call-bar .ic-av:nth-child(2) { margin-left: -12px; }
    .incoming-call-bar .ic-info { flex: 1; min-width: 0; }
    .incoming-call-bar .ic-title { font-weight: 700; font-size: 0.92rem; }
    .incoming-call-bar .ic-sub { font-size: 0.76rem; color: #7c80a0; }
    .incoming-call-bar .ic-btn { padding: 8px 18px; border-radius: 8px; border: none; font-family: 'DM Sans', sans-serif; font-size: 0.82rem; font-weight: 700; cursor: pointer; }
    .ic-btn-accept { background: #23d18b; color: #000; }
    .ic-btn-decline { background: #ff5f57; color: #fff; margin-left: 8px; }

    /* ── OUTGOING CALL MODAL ── */
    .call-modal-inner { display: flex; flex-direction: column; align-items: center; gap: 20px; padding: 12px 0 4px; }
    .call-avatars-row { display: flex; align-items: center; gap: 0; }
    .call-av { width: 72px; height: 72px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 1.6rem; color: #fff; overflow: hidden; border: 3px solid var(--surface); flex-shrink: 0; }
    .call-av-sep { font-size: 1.4rem; margin: 0 6px; color: var(--muted); animation: callPulse 1.5s infinite; }
    @keyframes callPulse { 0%,100%{opacity:1;transform:scale(1)} 50%{opacity:0.4;transform:scale(0.85)} }
    .call-name-big { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 1.3rem; }
    .call-status-text { color: var(--muted); font-size: 0.88rem; }
    .call-end-btn { padding: 12px 32px; background: var(--error); color: #fff; border: none; border-radius: 10px; font-family: 'DM Sans', sans-serif; font-size: 0.92rem; font-weight: 700; cursor: pointer; transition: background 0.2s; }
    .call-end-btn:hover { background: #e04040; }

    /* ── MESSAGE ACTIONS ── */
    .chat-msg { position: relative; }
    .msg-actions { position: absolute; right: 8px; top: 50%; transform: translateY(-50%); display: none; background: var(--surface2); border: 1px solid var(--border); border-radius: 8px; padding: 2px 4px; gap: 2px; align-items: center; z-index: 10; }
    .chat-msg:hover .msg-actions { display: flex; }
    .msg-action-btn { background: none; border: none; color: var(--muted); cursor: pointer; font-size: 0.82rem; padding: 4px 7px; border-radius: 5px; transition: background 0.15s, color 0.15s; white-space: nowrap; }
    .msg-action-btn:hover { background: var(--surface3); color: var(--text); }
    .msg-action-btn.delete:hover { color: var(--error); }
    .msg-edit-area { margin-top: 6px; display: flex; gap: 8px; }
    .msg-edit-input { flex: 1; background: var(--surface2); border: 1px solid var(--accent); border-radius: 8px; padding: 8px 10px; color: var(--text); font-family: 'DM Sans', sans-serif; font-size: 0.88rem; outline: none; }
    .msg-edited-tag { font-size: 0.66rem; color: var(--muted); margin-left: 4px; font-style: italic; }
        @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }

    ::-webkit-scrollbar { width: 4px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--surface3); border-radius: 2px; }
  </style>
</head>
<body>

<!-- MOBILE SIDEBAR OVERLAY -->
<div class="sidebar-overlay" id="sidebar-overlay" onclick="closeMobileSidebar()"></div>

<!-- LIGHTBOX -->
<div class="lightbox" id="lightbox" onclick="this.classList.remove('open')"><img id="lightbox-img" src="" alt=""/></div>
<div class="toast" id="toast"></div>

<!-- ═══ ALL MODALS ═══ -->

<!-- CREATE SERVER -->
<div class="modal-overlay" id="createServerModal">
  <div class="modal">
    <button class="modal-close" onclick="closeModal('createServerModal')">×</button>
    <h2>Create a Server</h2><p>Give your community a home.</p>
    <div class="server-type-grid">
      <div class="server-type-card selected" onclick="selectServerType(this)"><div class="type-icon">🎮</div><div class="type-name">Gaming</div></div>
      <div class="server-type-card" onclick="selectServerType(this)"><div class="type-icon">🎨</div><div class="type-name">Creative</div></div>
      <div class="server-type-card" onclick="selectServerType(this)"><div class="type-icon">📚</div><div class="type-name">Education</div></div>
      <div class="server-type-card" onclick="selectServerType(this)"><div class="type-icon">💬</div><div class="type-name">Community</div></div>
    </div>
    <div class="form-group"><label>Server Name</label><input type="text" id="server-name-input" placeholder="My awesome server"/></div>
    <button class="modal-btn" onclick="createServer()">Create Server</button>
  </div>
</div>

<!-- JOIN SERVER VIA INVITE -->
<div class="modal-overlay" id="joinServerModal">
  <div class="modal">
    <button class="modal-close" onclick="closeModal('joinServerModal')">×</button>
    <h2>Join a Server</h2><p>Enter an invite link or code to join a server.</p>
    <div class="add-result" id="join-result"></div>
    <div class="form-group"><label>Invite Link or Code</label><input type="text" id="join-invite-input" placeholder="https://nexus.app/invite/abc123 or abc123"/></div>
    <button class="modal-btn" onclick="joinServerViaInvite()">Join Server</button>
  </div>
</div>

<!-- INVITE LINK MODAL -->
<div class="modal-overlay" id="inviteModal">
  <div class="modal">
    <button class="modal-close" onclick="closeModal('inviteModal')">×</button>
    <h2>Invite People</h2><p class="modal-desc" id="invite-server-name"></p>
    <div class="form-group">
      <label>Link Expiry</label>
      <select id="invite-expiry">
        <option value="never">Never expires</option>
        <option value="1">1 Day</option>
        <option value="7">7 Days</option>
      </select>
    </div>
    <button class="modal-btn secondary" onclick="generateInvite()">Generate Link</button>
    <div id="invite-link-display" style="display:none">
      <div class="invite-link-box">
        <span id="invite-link-text"></span>
        <button class="copy-btn" onclick="copyInviteLink()">Copy</button>
      </div>
      <p style="font-size:0.76rem;color:var(--muted)" id="invite-expiry-note"></p>
    </div>
  </div>
</div>

<!-- MANAGE ROLES MODAL -->
<div class="modal-overlay" id="rolesModal">
  <div class="modal" style="max-width:520px">
    <button class="modal-close" onclick="closeModal('rolesModal')">×</button>
    <h2>Manage Roles</h2><p class="modal-desc">Create roles, set permissions, and assign them to members.</p>
    <div style="display:flex;gap:10px;margin-bottom:18px">
      <button class="modal-btn secondary" style="flex:none;width:auto;padding:8px 16px" onclick="showRolesTab('list')">Roles</button>
      <button class="modal-btn secondary" style="flex:none;width:auto;padding:8px 16px" onclick="showRolesTab('create')">+ New Role</button>
      <button class="modal-btn secondary" style="flex:none;width:auto;padding:8px 16px" onclick="showRolesTab('members')">Members</button>
    </div>
    <!-- Roles list tab -->
    <div id="roles-tab-list">
      <div id="roles-list-container"></div>
    </div>
    <!-- Create role tab -->
    <div id="roles-tab-create" style="display:none">
      <div class="form-group"><label>Role Name</label><input type="text" id="new-role-name" placeholder="e.g. Moderator"/></div>
      <div class="form-group">
        <label>Role Color</label>
        <div style="display:flex;gap:8px;flex-wrap:wrap" id="role-color-picker">
          <div class="role-color-swatch selected" data-color="#5b6af0" style="width:28px;height:28px;border-radius:50%;background:#5b6af0;cursor:pointer;border:3px solid #fff"></div>
          <div class="role-color-swatch" data-color="#e040fb" style="width:28px;height:28px;border-radius:50%;background:#e040fb;cursor:pointer;border:3px solid transparent"></div>
          <div class="role-color-swatch" data-color="#ff7043" style="width:28px;height:28px;border-radius:50%;background:#ff7043;cursor:pointer;border:3px solid transparent"></div>
          <div class="role-color-swatch" data-color="#23d18b" style="width:28px;height:28px;border-radius:50%;background:#23d18b;cursor:pointer;border:3px solid transparent"></div>
          <div class="role-color-swatch" data-color="#ffa726" style="width:28px;height:28px;border-radius:50%;background:#ffa726;cursor:pointer;border:3px solid transparent"></div>
          <div class="role-color-swatch" data-color="#f59e0b" style="width:28px;height:28px;border-radius:50%;background:#f59e0b;cursor:pointer;border:3px solid transparent"></div>
          <div class="role-color-swatch" data-color="#00bcd4" style="width:28px;height:28px;border-radius:50%;background:#00bcd4;cursor:pointer;border:3px solid transparent"></div>
          <div class="role-color-swatch" data-color="#ff5f57" style="width:28px;height:28px;border-radius:50%;background:#ff5f57;cursor:pointer;border:3px solid transparent"></div>
        </div>
      </div>
      <div class="form-group"><label>Permissions</label></div>
      <div class="perm-toggle"><span>Admin (can edit server, manage channels)</span><label class="toggle-switch"><input type="checkbox" id="perm-admin"/><span class="toggle-slider"></span></label></div>
      <div class="perm-toggle"><span>Manage Roles</span><label class="toggle-switch"><input type="checkbox" id="perm-manage-roles"/><span class="toggle-slider"></span></label></div>
      <div class="perm-toggle"><span>Send Messages</span><label class="toggle-switch"><input type="checkbox" id="perm-send" checked/><span class="toggle-slider"></span></label></div>
      <div class="perm-toggle"><span>View Channels</span><label class="toggle-switch"><input type="checkbox" id="perm-view" checked/><span class="toggle-slider"></span></label></div>
      <div class="perm-toggle"><span>Attach Files</span><label class="toggle-switch"><input type="checkbox" id="perm-files" checked/><span class="toggle-slider"></span></label></div>
      <button class="modal-btn" style="margin-top:16px" onclick="createRole()">Create Role</button>
    </div>
    <!-- Members tab -->
    <div id="roles-tab-members" style="display:none">
      <div id="members-roles-list"></div>
    </div>
  </div>
</div>

<!-- CHANNEL PERMISSIONS MODAL -->
<div class="modal-overlay" id="channelPermModal">
  <div class="modal" style="max-width:480px">
    <button class="modal-close" onclick="closeModal('channelPermModal')">×</button>
    <h2>Channel Permissions</h2><p class="modal-desc" id="ch-perm-name"></p>
    <div class="form-group"><label>Who can view this channel?</label>
      <select id="ch-perm-view-select"><option value="everyone">Everyone</option><option value="role">Specific Role Only</option></select>
    </div>
    <div id="ch-perm-role-group" style="display:none" class="form-group">
      <label>Required Role</label>
      <select id="ch-perm-role-select"></select>
    </div>
    <div class="form-group"><label>Who can send messages?</label>
      <select id="ch-perm-send-select"><option value="everyone">Everyone</option><option value="role">Specific Role Only</option></select>
    </div>
    <div id="ch-perm-send-role-group" style="display:none" class="form-group">
      <label>Required Role for Sending</label>
      <select id="ch-perm-send-role-select"></select>
    </div>
    <button class="modal-btn" onclick="saveChannelPerms()">Save Permissions</button>
  </div>
</div>

<!-- PROFILE MODAL -->
<div class="modal-overlay" id="profileModal">
  <div class="modal" style="max-width:480px">
    <button class="modal-close" onclick="closeModal('profileModal')">×</button>
    <h2>Edit Profile</h2><p>Customize how others see you on Nexus.</p>

    <!-- BANNER -->
    <div class="form-group" style="margin-bottom:10px">
      <label>Profile Banner</label>
      <div class="banner-upload-area" id="profile-banner-preview" onclick="document.getElementById('banner-file-input').click()">
        <div class="banner-upload-overlay">
          <button class="banner-upload-btn" onclick="event.stopPropagation();document.getElementById('banner-file-input').click()">📁 Upload</button>
          <button class="banner-upload-btn" id="banner-crop-btn" style="display:none" onclick="event.stopPropagation();openBannerCrop()">✂️ Crop</button>
          <button class="banner-upload-btn" id="banner-remove-btn" style="display:none" onclick="event.stopPropagation();removeBanner()">✕ Remove</button>
        </div>
      </div>
      <input type="file" id="banner-file-input" accept="image/*,image/gif" style="display:none" onchange="handleBannerUpload(event)"/>
      <p style="font-size:0.72rem;color:var(--muted);margin-top:5px">PNG, JPG or GIF · Max 8MB. Drag to reposition after cropping.</p>
    </div>

    <!-- AVATAR -->
    <div class="avatar-upload-area">
      <div class="avatar-preview" id="profile-avatar-preview"></div>
      <div class="avatar-upload-btns">
        <button class="upload-btn" onclick="document.getElementById('avatar-file-input').click()">Upload Photo</button>
        <button class="remove-btn" onclick="removeAvatar()">Remove</button>
        <p>JPG, PNG or GIF · Max 8MB</p>
      </div>
    </div>
    <input type="file" id="avatar-file-input" accept="image/*" style="display:none" onchange="handleAvatarUpload(event)"/>

    <!-- PROFILE EFFECTS -->
    <div class="form-group">
      <label>Profile Effect <span style="font-size:0.72rem;color:var(--muted);font-weight:400">(free — shown on your banner)</span></label>
      <div class="effect-grid" id="effect-grid"></div>
    </div>

    <div class="form-group"><label>Display Name</label><input type="text" id="display-name-input" placeholder="Your display name"/></div>
    <div class="form-group"><label>Bio</label><textarea id="bio-input" rows="3" placeholder="Tell people a little about yourself..."></textarea></div>
    <div class="form-group">
      <label>Status</label>
      <div class="status-selector">
        <div class="status-option selected" data-status="online" onclick="selectStatus(this)"><div class="status-pip" style="background:var(--online)"></div>Online</div>
        <div class="status-option" data-status="idle" onclick="selectStatus(this)"><div class="status-pip" style="background:var(--idle)"></div>Idle</div>
        <div class="status-option" data-status="dnd" onclick="selectStatus(this)"><div class="status-pip" style="background:var(--dnd)"></div>Do Not Disturb</div>
        <div class="status-option" data-status="invisible" onclick="selectStatus(this)"><div class="status-pip" style="background:var(--muted)"></div>Invisible</div>
      </div>
    </div>
    <div class="form-group"><label>Username (cannot be changed)</label><input type="text" id="username-readonly" disabled/></div>
    <div class="modal-btn-row" style="margin-bottom:20px">
      <button class="modal-btn secondary" onclick="closeModal('profileModal')">Cancel</button>
      <button class="modal-btn" onclick="saveProfile()">Save Changes</button>
    </div>
    <div class="danger-zone">
      <h4>⚠️ Danger Zone</h4>
      <p>Deleting your account removes your profile. Messages will show as "Deleted User". This cannot be undone.</p>
      <button class="modal-btn danger" onclick="confirmDeleteAccount()">Delete My Account</button>
    </div>
  </div>
</div>

<!-- BANNER CROP MODAL -->
<div class="modal-overlay" id="bannerCropModal">
  <div class="modal" style="max-width:520px">
    <button class="modal-close" onclick="closeModal('bannerCropModal')">×</button>
    <h2>✂️ Crop Banner</h2>
    <p>Drag to pan · Pinch or use the slider to zoom</p>
    <div class="crop-stage" id="crop-stage"></div>
    <div class="crop-hint">The dashed area is what will be shown as your banner.</div>
    <div class="crop-zoom-row">
      <label>Zoom</label>
      <input type="range" id="crop-zoom" min="100" max="400" value="100" oninput="updateCropZoom(this.value)"/>
      <span id="crop-zoom-label" style="font-size:0.78rem;color:var(--muted);width:36px">1×</span>
    </div>
    <div class="modal-btn-row" style="margin-top:16px">
      <button class="modal-btn secondary" onclick="closeModal('bannerCropModal')">Cancel</button>
      <button class="modal-btn" onclick="applyCrop()">Apply Crop</button>
    </div>
  </div>
</div>

<!-- CONFIRM DELETE ACCOUNT -->
<div class="modal-overlay" id="deleteAccountModal">
  <div class="modal" style="max-width:400px">
    <button class="modal-close" onclick="closeModal('deleteAccountModal')">×</button>
    <h2>Delete Account</h2><p>Are you absolutely sure? Type DELETE to confirm.</p>
    <div class="form-group"><input type="text" id="delete-confirm-input" placeholder="DELETE"/></div>
    <div class="modal-btn-row">
      <button class="modal-btn secondary" onclick="closeModal('deleteAccountModal')">Cancel</button>
      <button class="modal-btn danger" onclick="deleteAccount()">Yes, Delete</button>
    </div>
  </div>
</div>

<!-- CALL MODAL -->
<!-- INCOMING CALL BANNER (top of screen) -->
<div class="incoming-call-bar" id="incoming-call-bar">
  <div class="ic-avatars">
    <div class="ic-av" id="ic-caller-av"></div>
    <div class="ic-av" id="ic-my-av"></div>
  </div>
  <div class="ic-info">
    <div class="ic-title" id="ic-caller-name">Someone</div>
    <div class="ic-sub">Incoming call...</div>
  </div>
  <button class="ic-btn ic-btn-accept" onclick="acceptCall()">✓ Accept</button>
  <button class="ic-btn ic-btn-decline" onclick="declineCall()">✕ Decline</button>
</div>

<!-- OUTGOING CALL MODAL -->
<div class="modal-overlay" id="callModal">
  <div class="modal" style="max-width:340px;text-align:center;transition:max-width 0.3s;">
    <div class="call-modal-inner">
      <!-- Screen share display area (hidden until someone shares) -->
      <div class="screenshare-view" id="screenshare-view">
        <video class="screenshare-video" id="screenshare-video" autoplay playsinline></video>
        <div class="screenshare-label" id="screenshare-label">Someone is sharing their screen</div>
        <!-- Local cam pip while viewing remote share -->
        <div class="screenshare-pip" id="screenshare-pip">
          <video id="screenshare-self-pip" autoplay muted playsinline></video>
        </div>
      </div>
      <!-- Participants avatars (hidden when viewing fullscreen share) -->
      <div class="call-participants-row" id="call-participants-row"></div>
      <div class="call-status-text" id="call-status">Connecting...</div>
      <!-- Controls row -->
      <div class="call-controls">
        <button class="call-share-btn" id="screenshare-btn" onclick="toggleScreenShare()">🖥️ Share Screen</button>
        <button class="call-share-btn" id="mute-btn" onclick="toggleMute()">🎤 Mute</button>
      </div>
      <button class="call-end-btn" onclick="endCall()">📵 End Call</button>
    </div>
  </div>
</div>

<!-- CALL PIP (bottom-right corner, visible to everyone in call) -->
<div class="call-pip" id="call-pip">
  <div class="call-pip-avatars" id="call-pip-avatars"></div>
  <div class="call-pip-info">
    <div class="call-pip-title">📞 In Call</div>
    <div class="call-pip-sub" id="call-pip-sub">Calling...</div>
  </div>
  <button class="call-pip-end" onclick="endCall()">End</button>
</div>

<!-- GROUP CHAT CREATE MODAL -->
<div class="modal-overlay" id="newGcModal">
  <div class="modal" style="max-width:420px">
    <button class="modal-close" onclick="closeModal('newGcModal')">×</button>
    <h2>New Group Chat</h2>
    <p>Select friends to add (max 9, you + 9 = 10).</p>
    <div style="margin:8px 0 4px;font-size:0.78rem;color:var(--muted)">Group name (optional)</div>
    <input type="text" id="gc-name-input" placeholder="e.g. The Squad" style="width:100%;background:var(--surface2);border:1px solid var(--border);border-radius:8px;padding:10px 12px;color:var(--text);font-family:'DM Sans',sans-serif;font-size:0.9rem;outline:none;margin-bottom:10px"/>
    <div class="gc-members-grid" id="gc-friends-list"></div>
    <button class="modal-btn" style="margin-top:14px" onclick="createGroupChat()">Create Group Chat</button>
  </div>
</div>

<!-- ADD FRIEND -->
<div class="modal-overlay" id="addFriendModal">
  <div class="modal">
    <button class="modal-close" onclick="closeModal('addFriendModal')">×</button>
    <h2>Add Friend</h2><p>Add friends with their Nexus username.</p>
    <div class="add-result" id="add-friend-result-modal"></div>
    <div class="form-group"><label>Username</label><input type="text" id="add-friend-input-modal" placeholder="e.g. cool_user"/></div>
    <button class="modal-btn" onclick="sendFriendRequest()">Send Friend Request</button>
  </div>
</div>

<!-- ADMIN ACTION -->
<div class="modal-overlay" id="adminActionModal">
  <div class="modal" style="max-width:420px">
    <button class="modal-close" onclick="closeModal('adminActionModal')">×</button>
    <h2 id="admin-action-title"></h2><p class="modal-desc" id="admin-action-desc"></p>
    <div class="form-group" id="admin-reason-group"><label>Reason</label><textarea id="admin-reason-input" rows="3" placeholder="Enter a reason..."></textarea></div>
    <div class="form-group" id="admin-date-group" style="display:none"><label>Ban Until</label><input type="date" id="admin-ban-until"/></div>
    <div class="modal-btn-row">
      <button class="modal-btn secondary" onclick="closeModal('adminActionModal')">Cancel</button>
      <button class="modal-btn" id="admin-action-confirm-btn" onclick="executeAdminAction()">Confirm</button>
    </div>
  </div>
</div>

<!-- ═══ LAYOUT ═══ -->
<div class="servers-bar" id="servers-bar">
  <div class="server-icon home active" onclick="showView()" title="Home"><span class="server-pip"></span>⌂</div>
  <div class="server-divider"></div>
  <div class="server-icon add" id="add-server-btn" onclick="showServerOptions()" title="Add/Join Server">+</div>
</div>

<div class="sidebar" id="sidebar">
  <div class="sidebar-header">
    <span id="sidebar-title">💬 Direct Messages</span>
    <button class="icon-btn" id="sidebar-action-btn" onclick="openModal('addFriendModal')" title="Add Friend" style="font-size:1.1rem">+</button>
  </div>
  <div class="sidebar-search"><input type="text" id="sidebar-search-input" placeholder="Search..." oninput="filterSidebar()"/></div>
  <div class="sidebar-scroll" id="sidebar-scroll">
    <div class="sidebar-section-label">DIRECT MESSAGES <button class="sl-btn" title="New Group Chat" onclick="openNewGcModal()">+</button></div>
    <div id="dm-list"></div>
    <div class="sidebar-section-label" style="margin-top:8px">GROUP CHATS <button class="sl-btn" title="New Group Chat" onclick="openNewGcModal()">+</button></div>
    <div id="gc-list"></div>
  </div>
  <div class="user-panel" onclick="openProfileModal()">
    <div class="user-panel-avatar" id="sidebar-avatar"></div>
    <div class="user-panel-info">
      <div class="user-panel-name" id="sidebar-display-name">Loading...</div>
      <div class="user-panel-tag" id="sidebar-username">@...</div>
    </div>
    <div class="user-panel-actions">
      <button class="icon-btn" title="Nexus Feed" onclick="event.stopPropagation();window.location.href='feed.html'">🌐</button>
      <button class="icon-btn" onclick="event.stopPropagation();openProfileModal()">⚙️</button>
      <button class="icon-btn" onclick="event.stopPropagation();handleSignOut()">🚪</button>
    </div>
  </div>
</div>

<div class="main">
  <div class="main-header" id="main-header">
    <button class="hamburger" id="hamburger-btn" onclick="toggleMobileSidebar()">☰</button>
    <span>👥</span><h2>Friends</h2>
    <div class="header-tabs">
      <button class="tab active" onclick="switchTab(this,'online')">Online</button>
      <button class="tab" onclick="switchTab(this,'all')">All</button>
      <button class="tab" onclick="switchTab(this,'pending')">Pending&nbsp;<span id="pending-count" style="display:none" class="pending-badge">0</span></button>
    </div>
    <button class="add-friend-btn" onclick="openModal('addFriendModal')">+ Add Friend</button>
  </div>
  <div class="main-content" id="main-content">
    <div class="empty-state"><div class="empty-icon">👋</div><h3>Welcome to Nexus!</h3><p>Add friends to get started.</p></div>
  </div>
</div>

<div class="profile-panel hidden" id="profile-panel">
  <div class="pp-banner" id="pp-banner">
    <button class="pp-close-btn" onclick="document.getElementById('profile-panel').classList.add('hidden');stopProfileParticles()">×</button>
  </div>
  <!-- Avatar sits between banner and body as a flex sibling — avoids overflow-y:auto clipping -->
  <div class="pp-avatar-shelf">
    <div class="pp-avatar-wrap"><div class="pp-avatar" id="pp-avatar"></div><div class="pp-status-badge" id="pp-status-badge"></div></div>
  </div>
  <div class="pp-body">
    <div class="pp-name" id="pp-name"></div>
    <div class="pp-username" id="pp-username"></div>
    <div class="pp-status-line" id="pp-status-line"></div>
    <div class="pp-divider"></div>
    <div id="pp-bio-wrap" style="display:none"><div class="pp-section-title">About Me</div><div class="pp-bio" id="pp-bio"></div><div class="pp-divider"></div></div>
    <div class="pp-section-title">Member Since</div>
    <div class="pp-since" id="pp-since"></div>
    <button class="pp-dm-btn" id="pp-dm-btn" style="display:none" onclick="openDmFromPanel()">💬 Send Message</button>
    <button class="pp-feed-btn" id="pp-feed-btn" style="display:none" onclick="openFeedProfile()">🌐 View on Nexus Feed</button>
  </div>
</div>

<!-- MOBILE BOTTOM NAV -->
<div class="mobile-nav" id="mobile-nav">
  <button class="mobile-nav-btn active" id="mnav-home" onclick="mobileNav('home',this)">🏠<span>Home</span></button>
  <button class="mobile-nav-btn mobile-nav-badge" id="mnav-dms" data-badge="" onclick="mobileNav('dms',this)">💬<span>DMs</span></button>
  <button class="mobile-nav-btn" id="mnav-servers" onclick="mobileNav('servers',this)">🏰<span>Servers</span></button>
  <button class="mobile-nav-btn" onclick="window.location.href='feed.html'">🌐<span>Feed</span></button>
  <button class="mobile-nav-btn" id="mnav-profile" onclick="openProfileModal()">👤<span>Profile</span></button>
</div>

<input type="file" id="dm-file-input" style="display:none" accept="image/*,video/*,audio/*,.pdf,.doc,.docx,.txt,.zip,.rar" onchange="handleDmFileUpload(event)"/>
<input type="file" id="ch-file-input" style="display:none" accept="image/*,video/*,audio/*,.pdf,.doc,.docx,.txt,.zip,.rar" onchange="handleChFileUpload(event)"/>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
  import { getAuth, onAuthStateChanged, signOut, deleteUser } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-auth.js";
  import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, collection, query, where, getDocs, addDoc, onSnapshot, orderBy, serverTimestamp, limit, arrayUnion } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-firestore.js";

  const CLOUDINARY_CLOUD = 'dskssf3tn';
  const CLOUDINARY_PRESET = 'nexus_avatars';
  const ADMIN_USERNAMES = ['rivalsonts', 'ds64'];
  const BASE_URL = window.location.origin + window.location.pathname.replace('dashboard.html','');

  const app = initializeApp({
    apiKey: "AIzaSyDKGqss5jcCNd_AYYohYs-KaSKvZUemX-4",
    authDomain: "nexus-app-74493.firebaseapp.com",
    projectId: "nexus-app-74493",
    storageBucket: "nexus-app-74493.firebasestorage.app",
    messagingSenderId: "179885556901",
    appId: "1:179885556901:web:1966afe8102de60d9cb94c"
  });
  const auth = getAuth(app);
  const db = getFirestore(app);

  let currentUser = null, currentProfile = null, pendingAvatarDataUrl = null;
  let currentDmFriend = null, dmUnsubscribe = null, chUnsubscribe = null;
  let selectedStatus = 'online', isAdmin = false;
  let adminActionTarget = null, adminActionType = null;
  let currentServer = null, currentChannel = null;
  let selectedRoleColor = '#5b6af0';
  let currentChannelForPerms = null;
  let typingTimeout = null, typingUnsubscribe = null;
  let currentInviteServerData = null;
  let profilePanelUser = null;
  // Cache of uid -> user profile data to avoid re-fetching in channel messages
  const userCache = {};

  // ── AUTH ──
  onAuthStateChanged(auth, async user => {
    if (!user) { window.location.href = 'index.html'; return; }
    currentUser = user;
    await loadProfile();

    // Check ban
    const banSnap = await getDoc(doc(db,'bans',currentUser.uid));
    if (banSnap.exists()) {
      const ban = banSnap.data();
      if (ban.type === 'permanent') { await signOut(auth); window.location.href = 'index.html'; return; }
      if (ban.type === 'temporary' && ban.until) {
        const until = ban.until.toDate ? ban.until.toDate() : new Date(ban.until);
        if (new Date() < until) { await signOut(auth); window.location.href = 'index.html'; return; }
        else await deleteDoc(doc(db,'bans',currentUser.uid));
      }
    }

    isAdmin = ADMIN_USERNAMES.includes(currentProfile.username);
    if (isAdmin) addAdminButton();

    try { await updateDoc(doc(db,'users',currentUser.uid), { status: currentProfile.manualStatus || 'online' }); } catch(e){}
    await loadFriends();
    await loadServers();

    // Check for invite in URL
    const urlParams = new URLSearchParams(window.location.search);
    const inviteCode = urlParams.get('invite');
    if (inviteCode) handleInviteFromUrl(inviteCode);

    listenForIncomingCalls();
    listenForGroupCallInvites();
    await loadGroupChats();
    startPresenceHeartbeat();

    window.addEventListener('beforeunload', async () => {
      try { await updateDoc(doc(db,'users',currentUser.uid), { status: currentProfile.manualStatus==='invisible'?'invisible':'offline' }); } catch(e){}
    });
  });

  async function loadProfile() {
    const snap = await getDoc(doc(db,'users',currentUser.uid));
    currentProfile = snap.exists() ? snap.data() : { username: currentUser.email, displayName:'', avatarUrl:'', bio:'', status:'online' };
    if (currentProfile.deleted) { await signOut(auth); window.location.href='index.html'; return; }
    selectedStatus = currentProfile.status || 'online';
    // Seed own profile into cache
    userCache[currentUser.uid] = {...currentProfile, id:currentUser.uid};
    updateSidebarUser();
  }

  function updateSidebarUser() {
    const name = currentProfile.displayName || currentProfile.username;
    document.getElementById('sidebar-display-name').textContent = name;
    document.getElementById('sidebar-username').textContent = '@' + currentProfile.username;
    const av = document.getElementById('sidebar-avatar');
    if (currentProfile.avatarUrl) { av.innerHTML = `<img src="${currentProfile.avatarUrl}"/>`; av.style.background = ''; }
    else { av.innerHTML = name[0].toUpperCase(); av.style.background = color(currentProfile.username); }
  }

  // ── ADMIN ──
  function addAdminButton() {
    // Desktop servers bar
    const bar = document.getElementById('servers-bar');
    const addBtn = bar.querySelector('.server-icon.add');
    const adminIcon = document.createElement('div');
    adminIcon.className = 'server-icon admin-icon';
    adminIcon.title = 'Admin Panel';
    adminIcon.innerHTML = `<span class="server-pip"></span>🛡️`;
    adminIcon.onclick = () => { document.querySelectorAll('.server-icon').forEach(i=>i.classList.remove('active')); adminIcon.classList.add('active'); showAdminPanel(); };
    bar.insertBefore(adminIcon, addBtn);

    // Mobile bottom nav — replace the Servers button with Admin
    const mobileNav = document.getElementById('mobile-nav');
    const adminMobileBtn = document.createElement('button');
    adminMobileBtn.className = 'mobile-nav-btn';
    adminMobileBtn.id = 'mnav-admin';
    adminMobileBtn.innerHTML = `🛡️<span>Admin</span>`;
    adminMobileBtn.onclick = () => {
      document.querySelectorAll('.mobile-nav-btn').forEach(b=>b.classList.remove('active'));
      adminMobileBtn.classList.add('active');
      closeMobileSidebar();
      showAdminPanel();
    };
    // Insert before the profile button
    const profileBtn = document.getElementById('mnav-profile');
    mobileNav.insertBefore(adminMobileBtn, profileBtn);
  }

  window.showAdminPanel = async function() {
    if (!isAdmin) return;
    document.getElementById('profile-panel').classList.add('hidden');
    document.getElementById('main-content').className='main-content chat-mode';
    document.getElementById('main-header').innerHTML = `<button class="hamburger" onclick="toggleMobileSidebar()">☰</button><span>🛡️</span><h2 style="color:var(--admin)">Admin Panel</h2>`;
    document.getElementById('main-content').innerHTML = `
      <div style="display:flex;flex-direction:column;height:100%">
        <div class="admin-toolbar">
          <input class="admin-search" id="admin-search" placeholder="Search username or email..." oninput="filterAdminUsers()"/>
          <select class="admin-filter" id="admin-filter" onchange="filterAdminUsers()">
            <option value="all">All</option><option value="active">Active</option>
            <option value="banned">Banned</option><option value="warned">Warned</option><option value="deleted">Deleted</option>
          </select>
        </div>
        <div class="admin-stats" id="admin-stats">
          <div class="admin-stat"><div class="admin-stat-num" id="stat-total">—</div><div class="admin-stat-label">Total</div></div>
          <div class="admin-stat"><div class="admin-stat-num" id="stat-active" style="color:var(--success)">—</div><div class="admin-stat-label">Active</div></div>
          <div class="admin-stat"><div class="admin-stat-num" id="stat-banned" style="color:var(--error)">—</div><div class="admin-stat-label">Banned</div></div>
          <div class="admin-stat"><div class="admin-stat-num" id="stat-deleted" style="color:var(--muted)">—</div><div class="admin-stat-label">Deleted</div></div>
        </div>
        <div class="admin-table-header"><div>User</div><div>Email</div><div>Joined</div><div>Status</div><div>Actions</div></div>
        <div class="admin-table" id="admin-user-list"><div class="admin-empty">Loading...</div></div>
      </div>`;
    await loadAdminUsers();
  };

  let allAdminUsers = [];
  async function loadAdminUsers() {
    const [usersSnap, bansSnap] = await Promise.all([getDocs(collection(db,'users')), getDocs(collection(db,'bans'))]);
    const bans = {}; bansSnap.docs.forEach(d => { bans[d.id] = d.data(); });
    allAdminUsers = usersSnap.docs.map(d => ({ id: d.id, ...d.data(), ban: bans[d.id] || null }));
    const total = allAdminUsers.length;
    const banned = allAdminUsers.filter(u => u.ban && (u.ban.type==='permanent'||u.ban.type==='temporary')).length;
    const deleted = allAdminUsers.filter(u => u.deleted).length;
    const el = id => document.getElementById(id);
    if (el('stat-total')) { el('stat-total').textContent=total; el('stat-active').textContent=total-banned-deleted; el('stat-banned').textContent=banned; el('stat-deleted').textContent=deleted; }
    renderAdminUsers(allAdminUsers);
  }

  window.filterAdminUsers = function() {
    const search=(document.getElementById('admin-search')?.value||'').toLowerCase();
    const filter=document.getElementById('admin-filter')?.value||'all';
    let users=allAdminUsers;
    if (search) users=users.filter(u=>(u.username||'').includes(search)||(u.email||'').includes(search)||(u.displayName||'').includes(search));
    if (filter==='active') users=users.filter(u=>!u.deleted&&!u.ban);
    else if (filter==='banned') users=users.filter(u=>u.ban&&(u.ban.type==='permanent'||u.ban.type==='temporary'));
    else if (filter==='warned') users=users.filter(u=>u.ban&&u.ban.type==='warning');
    else if (filter==='deleted') users=users.filter(u=>u.deleted);
    renderAdminUsers(users);
  };

  function renderAdminUsers(users) {
    const list=document.getElementById('admin-user-list'); if(!list) return;
    if (!users.length) { list.innerHTML='<div class="admin-empty">No users found.</div>'; return; }
    list.innerHTML='';
    users.forEach(u => {
      const name=u.displayName||u.username||'Unknown';
      const joined=u.createdAt?new Date(u.createdAt).toLocaleDateString():'—';
      const isSelf=u.id===currentUser.uid, isAdminAcc=ADMIN_USERNAMES.includes(u.username);
      let badge='';
      if (u.deleted) badge=`<span class="admin-badge badge-deleted">Deleted</span>`;
      else if (u.ban?.type==='permanent') badge=`<span class="admin-badge badge-banned">Banned</span>`;
      else if (u.ban?.type==='temporary') badge=`<span class="admin-badge badge-temp">Temp Ban</span>`;
      else if (u.ban?.type==='warning') badge=`<span class="admin-badge badge-warned">Warned</span>`;
      else badge=`<span class="admin-badge badge-active">Active</span>`;
      let actions='';
      if (!isSelf&&!isAdminAcc&&!u.deleted) {
        const hasBan=u.ban&&(u.ban.type==='permanent'||u.ban.type==='temporary');
        actions=`<button class="admin-btn admin-btn-warn" onclick="openAdminAction('${u.id}','warn','${esc(name)}')">⚠️</button><button class="admin-btn admin-btn-temp" onclick="openAdminAction('${u.id}','temp','${esc(name)}')">⏳</button>${hasBan?`<button class="admin-btn admin-btn-unban" onclick="openAdminAction('${u.id}','unban','${esc(name)}')">✓</button>`:`<button class="admin-btn admin-btn-ban" onclick="openAdminAction('${u.id}','ban','${esc(name)}')">🔨</button>`}<button class="admin-btn admin-btn-delete" onclick="openAdminAction('${u.id}','admindelete','${esc(name)}')">🗑</button>`;
      } else if (isSelf) actions=`<span style="font-size:0.72rem;color:var(--muted)">You</span>`;
      else if (isAdminAcc) actions=`<span style="font-size:0.72rem;color:var(--admin)">Admin 🛡️</span>`;
      else if (u.deleted) actions=`<span style="font-size:0.72rem;color:var(--muted)">Deleted</span>`;
      const row=document.createElement('div'); row.className='admin-user-row';
      row.innerHTML=`<div class="admin-user-info"><div class="admin-avatar" style="background:${color(u.username||'x')}">${u.avatarUrl?`<img src="${u.avatarUrl}"/>`:((name[0]||'?').toUpperCase())}</div><div><div class="admin-user-name">${esc(name)}</div><div class="admin-user-tag">@${u.username||'—'}</div></div></div><div style="font-size:0.78rem;color:var(--muted);overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${esc(u.email||'—')}</div><div style="font-size:0.78rem;color:var(--muted)">${joined}</div><div>${badge}</div><div class="admin-actions">${actions}</div>`;
      list.appendChild(row);
      if (u.ban?.reason) { const r=document.createElement('div'); r.style.cssText='padding:3px 20px 8px 62px;font-size:0.74rem;color:var(--muted);border-bottom:1px solid var(--border)'; r.textContent=`Reason: ${u.ban.reason}`; list.appendChild(r); }
    });
  }

  window.openAdminAction = function(uid,type,name) {
    adminActionTarget=uid; adminActionType=type;
    const titles={warn:'⚠️ Warn User',temp:'⏳ Temporary Ban',ban:'🔨 Permanent Ban',unban:'✓ Unban User',admindelete:'🗑 Delete Account'};
    const descs={warn:`Issue a warning to <strong>${name}</strong>. Their account stays active.`,temp:`Temporarily ban <strong>${name}</strong>.`,ban:`Permanently ban <strong>${name}</strong>.`,unban:`Remove all bans from <strong>${name}</strong>.`,admindelete:`Soft-delete <strong>${name}</strong>'s account.`};
    document.getElementById('admin-action-title').textContent=titles[type];
    document.getElementById('admin-action-desc').innerHTML=descs[type];
    document.getElementById('admin-reason-input').value='';
    document.getElementById('admin-date-group').style.display=type==='temp'?'flex':'none';
    document.getElementById('admin-reason-group').style.display=type==='unban'?'none':'flex';
    const btn=document.getElementById('admin-action-confirm-btn');
    btn.className='modal-btn'+(type==='ban'||type==='admindelete'?' danger':type==='unban'?' secondary':'');
    btn.textContent=type==='unban'?'Remove Ban':type==='admindelete'?'Delete':'Confirm';
    openModal('adminActionModal');
  };
  window.executeAdminAction = async function() {
    const uid=adminActionTarget, type=adminActionType;
    const reason=document.getElementById('admin-reason-input')?.value.trim()||'';
    try {
      if (type==='warn') await setDoc(doc(db,'bans',uid),{type:'warning',reason,issuedBy:currentUser.uid,issuedAt:serverTimestamp()});
      else if (type==='temp') { const until=document.getElementById('admin-ban-until').value; if(!until){showToast('Select a date','error');return;} await setDoc(doc(db,'bans',uid),{type:'temporary',reason,until:new Date(until),issuedBy:currentUser.uid,issuedAt:serverTimestamp()}); }
      else if (type==='ban') await setDoc(doc(db,'bans',uid),{type:'permanent',reason,issuedBy:currentUser.uid,issuedAt:serverTimestamp()});
      else if (type==='unban') await deleteDoc(doc(db,'bans',uid));
      else if (type==='admindelete') await updateDoc(doc(db,'users',uid),{deleted:true,deletedAt:serverTimestamp(),displayName:'Deleted User',avatarUrl:'',bio:''});
      showToast('Done!','success'); closeModal('adminActionModal'); await loadAdminUsers();
    } catch(e) { showToast('Error: '+e.message,'error'); }
  };

  // ── FRIENDS ──
  async function loadFriends() {
    const snap = await getDocs(query(collection(db,'friendships'),where('users','array-contains',currentUser.uid),where('status','==','accepted')));
    const friends = [];
    for (const d of snap.docs) {
      const friendId = d.data().users.find(id=>id!==currentUser.uid);
      const fs = await getDoc(doc(db,'users',friendId));
      if (fs.exists()) friends.push({id:friendId,...fs.data()});
    }
    window._friends = friends;
    renderDmList(friends);
    renderFriendsView(friends);
    await loadPendingRequests();
  }

  function statusColor(s) { return s==='online'?'var(--online)':s==='idle'?'var(--idle)':s==='dnd'?'var(--dnd)':'var(--muted)'; }
  function statusLabel(s) { return {online:'Online',idle:'Idle',dnd:'Do Not Disturb',invisible:'Offline',offline:'Offline'}[s]||'Offline'; }
  function visibleStatus(s) { return s==='invisible'?'offline':(s||'offline'); }

  function renderDmList(friends) {
    const list=document.getElementById('dm-list'); list.innerHTML='';
    if (!friends.length) { list.innerHTML='<div style="padding:8px 16px;font-size:0.78rem;color:var(--muted)">No friends yet</div>'; return; }
    friends.forEach(f => {
      const name=f.deleted?'Deleted User':(f.displayName||f.username);
      const vs=f.deleted?'offline':visibleStatus(f.status);
      const div=document.createElement('div'); div.className='sidebar-item';
      div._friendId = f.id;
      if (unreadDms.has(f.id)) div.classList.add('unread');
      div.innerHTML=`<div class="item-avatar" style="background:${f.deleted?'var(--muted)':color(f.username)}">${f.avatarUrl&&!f.deleted?`<img src="${f.avatarUrl}"/>`:name[0].toUpperCase()}<span class="status-dot ${vs}"></span></div><span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap${f.deleted?';color:var(--muted)':''}">${name}</span><span class="unread-dot"></span>`;
      div.onclick=()=>{ closeMobileSidebar(); markRead(f.id); openDm(f); };
      list.appendChild(div);
    });
  }

  function renderFriendsView(friends) {
    const content=document.getElementById('main-content'); content.className='main-content';
    if (!friends.length) { content.innerHTML=`<div class="empty-state"><div class="empty-icon">🤝</div><h3>No friends yet</h3><p>Add friends by clicking "+ Add Friend".</p></div>`; return; }
    content.innerHTML=`<div class="friends-list"></div>`;
    friends.forEach(f => {
      const name=f.deleted?'Deleted User':(f.displayName||f.username);
      const vs=f.deleted?'offline':visibleStatus(f.status);
      const row=document.createElement('div'); row.className='friend-row';
      row.innerHTML=`
        <div class="friend-avatar" style="background:${f.deleted?'var(--muted)':color(f.username||'x')};cursor:${f.deleted?'default':'pointer'}">
          ${f.avatarUrl&&!f.deleted?`<img src="${f.avatarUrl}"/>`:`${name[0].toUpperCase()}`}
          <span class="status-dot ${vs}" style="position:absolute;bottom:0;right:0;border-color:var(--bg)"></span>
        </div>
        <div class="friend-info" style="cursor:${f.deleted?'default':'pointer'}">
          <div class="friend-name" style="${f.deleted?'color:var(--muted)':''}">${name}</div>
          <div class="friend-status">${f.deleted?'Account deleted':statusLabel(vs)}</div>
        </div>
        <div class="friend-actions">
          <button class="friend-btn dm-btn" title="Message">💬</button>
          ${!f.deleted?`<button class="friend-btn call-btn" title="Call">📞</button>`:''}
        </div>`;
      if (!f.deleted) {
        row.querySelector('.friend-avatar').addEventListener('click', ()=>showProfilePanel(f));
        row.querySelector('.friend-info').addEventListener('click', ()=>showProfilePanel(f));
      }
      row.querySelector('.dm-btn').addEventListener('click', ()=>openDm(f));
      if (!f.deleted) { const cb=row.querySelector('.call-btn'); if(cb) cb.addEventListener('click', ()=>startCall(f)); }
      document.querySelector('.friends-list').appendChild(row);
    });
  }

  // ══════════════════════════════════════════════
  // ── PROFILE PARTICLE ENGINE ──
  // Canvas-based floating particles layered over the
  // entire profile panel for stars/sparkle effects.
  // ══════════════════════════════════════════════
  let _ppParticleRaf = null;
  window.stopProfileParticles = function() {
    if (_ppParticleRaf) { cancelAnimationFrame(_ppParticleRaf); _ppParticleRaf = null; }
    document.querySelectorAll('.pp-effect-canvas').forEach(c => c.remove());
  };
  function stopProfileParticles() { window.stopProfileParticles(); }

  function startProfileParticles(container, effect) {
    stopProfileParticles();
    if (effect === 'none' || !effect) return;

    const canvas = document.createElement('canvas');
    canvas.className = 'pp-effect-canvas';
    canvas.style.cssText = 'position:absolute;inset:0;width:100%;height:100%;pointer-events:none;z-index:0';
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let W = 0, H = 0;
    let particles = [];

    function resize() {
      W = canvas.width = container.offsetWidth;
      H = canvas.height = container.offsetHeight;
    }
    resize();
    const ro = new ResizeObserver(resize);
    ro.observe(container);

    // Build particle set based on effect
    function makeParticles() {
      particles = [];
      if (effect === 'sparkle' || effect === 'stars') {
        const count = effect === 'stars' ? 55 : 40;
        const symbols = effect === 'stars' ? ['✦','✧','⋆','·','★','✩'] : ['·','⊹','✦','˖'];
        for (let i = 0; i < count; i++) {
          particles.push({
            x: Math.random() * (W || 260),
            y: Math.random() * (H || 600),
            symbol: symbols[Math.floor(Math.random() * symbols.length)],
            size: effect === 'stars' ? 8 + Math.random() * 10 : 6 + Math.random() * 8,
            opacity: 0.1 + Math.random() * 0.7,
            speedY: effect === 'stars' ? -0.3 - Math.random() * 0.5 : -0.1 - Math.random() * 0.25,
            speedX: (Math.random() - 0.5) * 0.3,
            twinkleSpeed: 0.01 + Math.random() * 0.03,
            twinkleDir: Math.random() > 0.5 ? 1 : -1,
            hue: effect === 'stars' ? 220 + Math.random() * 60 : 260 + Math.random() * 80,
          });
        }
      } else if (effect === 'fire') {
        for (let i = 0; i < 30; i++) {
          particles.push({
            x: Math.random() * (W || 260),
            y: (H || 600) * (0.5 + Math.random() * 0.6),
            size: 3 + Math.random() * 7,
            opacity: 0.4 + Math.random() * 0.5,
            speedY: -0.8 - Math.random() * 1.2,
            speedX: (Math.random() - 0.5) * 0.5,
            life: Math.random(),
            decay: 0.008 + Math.random() * 0.012,
            hue: 15 + Math.random() * 30,
          });
        }
      } else if (effect === 'ice') {
        const symbols = ['❄','*','·','✦'];
        for (let i = 0; i < 25; i++) {
          particles.push({
            x: Math.random() * (W || 260),
            y: Math.random() * (H || 600),
            symbol: symbols[Math.floor(Math.random() * symbols.length)],
            size: 7 + Math.random() * 9,
            opacity: 0.15 + Math.random() * 0.5,
            speedY: 0.1 + Math.random() * 0.3,
            speedX: (Math.random() - 0.5) * 0.2,
            twinkleSpeed: 0.005 + Math.random() * 0.02,
            twinkleDir: 1,
          });
        }
      }
    }
    makeParticles();

    function draw() {
      ctx.clearRect(0, 0, W, H);

      particles.forEach(p => {
        ctx.save();
        if (effect === 'fire') {
          ctx.globalAlpha = p.opacity * p.life;
          const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
          grad.addColorStop(0, `hsla(${p.hue},100%,70%,1)`);
          grad.addColorStop(1, `hsla(${p.hue+20},100%,40%,0)`);
          ctx.fillStyle = grad;
          ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
          // Update
          p.x += p.speedX; p.y += p.speedY; p.life -= p.decay;
          if (p.life <= 0) { p.x = Math.random()*W; p.y = H*(0.5+Math.random()*0.6); p.life = 0.6+Math.random()*0.4; p.size = 3+Math.random()*7; }
        } else if (effect === 'sparkle' || effect === 'stars') {
          p.opacity += p.twinkleSpeed * p.twinkleDir;
          if (p.opacity > 0.85) { p.twinkleDir = -1; } else if (p.opacity < 0.05) { p.twinkleDir = 1; }
          ctx.globalAlpha = p.opacity;
          ctx.fillStyle = `hsl(${p.hue},80%,85%)`;
          ctx.font = `${p.size}px serif`;
          ctx.textAlign = 'center';
          ctx.fillText(p.symbol, p.x, p.y);
          p.x += p.speedX; p.y += p.speedY;
          if (p.y < -10) { p.y = H + 10; p.x = Math.random()*W; }
          if (p.x < -10) p.x = W+10; if (p.x > W+10) p.x = -10;
        } else if (effect === 'ice') {
          p.opacity += p.twinkleSpeed * p.twinkleDir;
          if (p.opacity > 0.65) p.twinkleDir = -1; else if (p.opacity < 0.05) p.twinkleDir = 1;
          ctx.globalAlpha = p.opacity;
          ctx.fillStyle = `hsl(200,80%,85%)`;
          ctx.font = `${p.size}px serif`;
          ctx.textAlign = 'center';
          ctx.fillText(p.symbol, p.x, p.y);
          p.x += p.speedX; p.y += p.speedY;
          if (p.y > H + 10) { p.y = -10; p.x = Math.random()*W; }
        }
        ctx.restore();
      });

      _ppParticleRaf = requestAnimationFrame(draw);
    }
    draw();
  }

  // Apply full-panel effect classes + particles to a container element
  function applyProfileEffect(container, effect) {
    // Remove old pfx- classes
    container.classList.forEach(c => { if (c.startsWith('pfx-')) container.classList.remove(c); });
    if (effect && effect !== 'none') container.classList.add('pfx-' + effect);
    // Particle-driven effects
    const particleEffects = new Set(['sparkle','stars','fire','ice']);
    if (particleEffects.has(effect)) {
      startProfileParticles(container, effect);
    } else {
      stopProfileParticles();
    }
  }

  // Also apply to mobile sheet body div
  function applyMobileSheetEffect(bodyEl, effect) {
    if (!bodyEl) return;
    bodyEl.classList.forEach(c => { if (c.startsWith('pfx-')) bodyEl.classList.remove(c); });
    bodyEl.style.position = 'relative';
    bodyEl.style.overflow = 'hidden';
    if (effect && effect !== 'none') {
      bodyEl.classList.add('pfx-' + effect);
      const particleEffects = new Set(['sparkle','stars','fire','ice']);
      if (particleEffects.has(effect)) startProfileParticles(bodyEl, effect);
    }
  }

  // ── PROFILE PANEL ──
  window.showProfilePanel = function(f) {
    if (!f || f.deleted) return;
    profilePanelUser = f;
    const name = f.displayName || f.username, vs = visibleStatus(f.status);
    const isMobile = window.innerWidth <= 680;

    if (isMobile) {
      const existing = document.getElementById('mobile-profile-sheet');
      if (existing) existing.remove();
      const ov = document.getElementById('mobile-profile-overlay');
      if (ov) ov.remove();
      stopProfileParticles();

      const sheet = document.createElement('div');
      sheet.id = 'mobile-profile-sheet';
      sheet.style.cssText = 'position:fixed;bottom:var(--mobile-nav-h);left:0;right:0;background:var(--surface);border-top:1px solid var(--border);border-radius:20px 20px 0 0;z-index:400;max-height:80vh;overflow-y:auto;box-shadow:0 -8px 32px rgba(0,0,0,0.5);animation:slideUp 0.25s ease';

      const since = f.createdAt ? new Date(f.createdAt).toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' }) : 'Unknown';
      const dmLine = f.id && f.id !== currentUser.uid ? `<button id="profile-sheet-dm-btn" style="width:100%;padding:11px;background:var(--accent);color:#fff;border:none;border-radius:8px;font-family:'DM Sans',sans-serif;font-size:0.88rem;font-weight:600;cursor:pointer">💬 Send Message</button>` : '';
      const feedLine = `<button id="profile-sheet-feed-btn" style="width:100%;margin-top:8px;padding:10px;background:transparent;color:var(--muted);border:1px solid var(--border);border-radius:8px;font-family:'DM Sans',sans-serif;font-size:0.88rem;font-weight:600;cursor:pointer">🌐 ${f.id===currentUser.uid?'My Nexus Feed':`View ${esc(f.displayName||f.username)}'s Feed`}</button>`;

      // Banner
      const fxClass = f.effect && f.effect !== 'none' ? ' fx-' + f.effect : '';
      let bannerInner = '';
      if (f.bannerUrl) {
        const isGif = f.bannerUrl.includes('.gif');
        const pos = f.bannerPos || '50% 50%';
        bannerInner = isGif
          ? `<video autoplay loop muted playsinline style="width:100%;height:100%;object-fit:cover;object-position:${pos};position:absolute;inset:0;" src="${f.bannerUrl}"></video>`
          : `<img src="${f.bannerUrl}" style="width:100%;height:100%;object-fit:cover;object-position:${pos};position:absolute;inset:0;"/>`;
      }
      const bannerBg = f.bannerUrl ? '' : `background:linear-gradient(135deg,${color(f.username)},${color(f.username + '2')})`;

      sheet.innerHTML = `
        <div style="width:40px;height:4px;background:var(--border);border-radius:2px;margin:12px auto 0"></div>
        <div class="pp-banner${fxClass}" style="height:100px;${bannerBg};border-radius:18px 18px 0 0;margin-top:-4px;position:relative;overflow:visible">
          <div style="position:absolute;inset:0;border-radius:18px 18px 0 0;overflow:hidden">${bannerInner}</div>
          <button id="profile-sheet-close" style="position:absolute;top:10px;right:12px;background:rgba(0,0,0,0.3);border:none;color:#fff;width:26px;height:26px;border-radius:50%;cursor:pointer;font-size:1rem;z-index:4">×</button>
          <!-- Avatar anchored to banner bottom — overflow:visible lets it poke out below -->
          <div style="position:absolute;bottom:-32px;left:20px;z-index:5;width:64px;height:64px;border-radius:50%;border:4px solid var(--surface);background:${color(f.username)};display:flex;align-items:center;justify-content:center;font-weight:700;font-size:1.3rem;color:#fff;overflow:hidden;box-shadow:0 2px 12px rgba(0,0,0,0.5)">
            ${f.avatarUrl ? '<img src="' + f.avatarUrl + '" style="width:100%;height:100%;object-fit:cover"/>' : name[0].toUpperCase()}
            <span style="position:absolute;bottom:2px;right:2px;width:15px;height:15px;border-radius:50%;border:3px solid var(--surface);background:${statusColor(vs)}"></span>
          </div>
        </div>
        <div id="profile-sheet-body" style="padding:40px 20px 24px;position:relative;overflow:hidden">
          <div style="font-family:Syne,sans-serif;font-weight:700;font-size:1.1rem;position:relative;z-index:1" class="sheet-name">${esc(name)}</div>
          <div style="font-size:0.8rem;color:var(--muted);margin-bottom:4px;position:relative;z-index:1">@${esc(f.username || '')}</div>
          <div style="font-size:0.82rem;color:var(--muted);display:flex;align-items:center;gap:6px;margin-bottom:14px;position:relative;z-index:1">
            <span style="width:8px;height:8px;border-radius:50%;background:${statusColor(vs)};display:inline-block;flex-shrink:0"></span>${statusLabel(vs)}
          </div>
          ${f.bio ? `<div style="font-size:0.7rem;font-weight:700;text-transform:uppercase;letter-spacing:0.06em;color:var(--muted);margin-bottom:4px;position:relative;z-index:1">About Me</div><div style="font-size:0.85rem;color:#c8cce0;line-height:1.6;margin-bottom:12px;position:relative;z-index:1">${esc(f.bio)}</div>` : ''}
          <div style="font-size:0.7rem;font-weight:700;text-transform:uppercase;letter-spacing:0.06em;color:var(--muted);margin-bottom:4px;position:relative;z-index:1">Member Since</div>
          <div style="font-size:0.82rem;color:var(--muted);margin-bottom:16px;position:relative;z-index:1">${since}</div>
          <div style="position:relative;z-index:1">${dmLine}${feedLine}</div>
        </div>`;

      document.body.appendChild(sheet);

      // Apply full-body effect to the sheet body div
      const bodyDiv = sheet.querySelector('#profile-sheet-body');
      if (f.effect && f.effect !== 'none') {
        applyMobileSheetEffect(bodyDiv, f.effect);
        // Name glow for neon/fire/ice/holo/glitch/aurora/sparkle
        const nameEl = sheet.querySelector('.sheet-name');
        if (nameEl) {
          const glowMap = {
            neon: '0 0 8px rgba(0,255,180,0.6),0 0 20px rgba(0,255,180,0.3)',
            fire: '0 0 8px rgba(255,120,0,0.7),0 0 20px rgba(255,80,0,0.4)',
            ice:  '0 0 8px rgba(160,230,255,0.7),0 0 20px rgba(120,200,255,0.4)',
            holo: '0 0 10px rgba(180,100,255,0.5),0 0 20px rgba(100,180,255,0.3)',
            aurora: '0 0 12px rgba(0,220,160,0.5)',
            sparkle: '0 0 6px rgba(200,180,255,0.6)',
            stars: '0 0 8px rgba(180,180,255,0.5)',
          };
          if (glowMap[f.effect]) nameEl.style.textShadow = glowMap[f.effect];
        }
      }

      sheet.querySelector('#profile-sheet-close').addEventListener('click', () => {
        sheet.remove(); stopProfileParticles();
        const o = document.getElementById('mobile-profile-overlay'); if (o) o.remove();
      });
      const dmBtn = sheet.querySelector('#profile-sheet-dm-btn');
      if (dmBtn) dmBtn.addEventListener('click', () => {
        sheet.remove(); stopProfileParticles();
        const o = document.getElementById('mobile-profile-overlay'); if (o) o.remove();
        openDm(f);
      });
      const feedBtnSheet = sheet.querySelector('#profile-sheet-feed-btn');
      if (feedBtnSheet) feedBtnSheet.addEventListener('click', () => {
        sheet.remove(); stopProfileParticles();
        const o = document.getElementById('mobile-profile-overlay'); if (o) o.remove();
        window.location.href = `feed.html?uid=${f.id}`;
      });
      const overlay = document.createElement('div');
      overlay.id = 'mobile-profile-overlay';
      overlay.style.cssText = 'position:fixed;inset:0;z-index:399;background:rgba(0,0,0,0.4)';
      overlay.addEventListener('click', () => { sheet.remove(); overlay.remove(); stopProfileParticles(); });
      document.body.insertBefore(overlay, sheet);

    } else {
      // ── DESKTOP PANEL ──
      document.getElementById('profile-panel').classList.remove('hidden');
      const panel = document.getElementById('profile-panel');
      const banner = document.getElementById('pp-banner');

      // Banner media + effect class
      banner.querySelectorAll('img,video').forEach(el => el.remove());
      banner.className = 'pp-banner' + (f.effect && f.effect !== 'none' ? ' fx-' + f.effect : '');
      if (f.bannerUrl) {
        const isGif = f.bannerUrl.includes('.gif');
        const bEl = isGif ? document.createElement('video') : document.createElement('img');
        if (isGif) { bEl.autoplay = true; bEl.loop = true; bEl.muted = true; bEl.playsInline = true; }
        bEl.src = f.bannerUrl;
        if (f.bannerPos) bEl.style.objectPosition = f.bannerPos;
        banner.insertBefore(bEl, banner.firstChild);
        banner.style.background = '';
      } else {
        banner.style.background = `linear-gradient(135deg,${color(f.username)},${color(f.username + '2')})`;
      }

      // Full-panel effect
      applyProfileEffect(panel, f.effect);

      const av = document.getElementById('pp-avatar'); av.style.background = color(f.username);
      av.innerHTML = f.avatarUrl ? `<img src="${f.avatarUrl}"/>` : name[0].toUpperCase();
      document.getElementById('pp-status-badge').style.background = statusColor(vs);
      document.getElementById('pp-name').textContent = name;
      document.getElementById('pp-username').textContent = '@' + f.username;
      document.getElementById('pp-status-line').innerHTML = `<span style="width:8px;height:8px;border-radius:50%;background:${statusColor(vs)};display:inline-block;flex-shrink:0"></span>${statusLabel(vs)}`;
      const bw = document.getElementById('pp-bio-wrap');
      if (f.bio) { bw.style.display = 'block'; document.getElementById('pp-bio').textContent = f.bio; } else bw.style.display = 'none';
      document.getElementById('pp-since').textContent = f.createdAt ? new Date(f.createdAt).toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' }) : 'Unknown';
      document.getElementById('pp-dm-btn').style.display = (!f.id || f.id === currentUser.uid) ? 'none' : 'block';
      const feedBtn = document.getElementById('pp-feed-btn');
      if (feedBtn) { feedBtn.style.display = 'block'; feedBtn.textContent = f.id === currentUser.uid ? '🌐 My Nexus Feed' : `🌐 View ${esc(f.displayName||f.username)}'s Feed`; }
    }
  };
  window.openDmFromPanel = () => { if (profilePanelUser) openDm(profilePanelUser); };
  window.openFeedProfile = () => {
    const uid = profilePanelUser?.id || currentUser?.uid;
    if (uid) window.location.href = `feed.html?uid=${uid}`;
  };

  // ── PENDING ──
  async function loadPendingRequests() {
    const snap=await getDocs(query(collection(db,'friendships'),where('to','==',currentUser.uid),where('status','==','pending')));
    window._pendingRequests=[];
    for (const d of snap.docs) {
      const fs=await getDoc(doc(db,'users',d.data().from));
      if (fs.exists()&&!fs.data().deleted) window._pendingRequests.push({docId:d.id,...fs.data(),fromUid:d.data().from});
    }
    const badge=document.getElementById('pending-count');
    if (badge) { if(window._pendingRequests.length){badge.textContent=window._pendingRequests.length;badge.style.display='inline';}else badge.style.display='none'; }
  }

  function renderPendingView() {
    const content=document.getElementById('main-content'); content.className='main-content';
    const reqs=window._pendingRequests||[];
    if (!reqs.length) { content.innerHTML=`<div class="empty-state"><div class="empty-icon">📭</div><h3>No pending requests</h3></div>`; return; }
    content.innerHTML=`<div class="friends-list"></div>`;
    reqs.forEach(r => {
      const name=r.displayName||r.username;
      const row=document.createElement('div'); row.className='request-row';
      row.innerHTML=`<div style="width:38px;height:38px;border-radius:50%;background:${color(r.username)};display:flex;align-items:center;justify-content:center;font-weight:700;color:#fff;overflow:hidden;flex-shrink:0">${r.avatarUrl?`<img src="${r.avatarUrl}" style="width:100%;height:100%;object-fit:cover"/>`:name[0].toUpperCase()}</div><div><div style="font-weight:600;font-size:0.9rem">${name}</div><div style="font-size:0.76rem;color:var(--muted)">@${r.username}</div></div><div class="request-actions"><button class="req-btn accept" onclick="acceptRequest('${r.docId}')">✓</button><button class="req-btn decline" onclick="declineRequest('${r.docId}')">✗</button></div>`;
      document.querySelector('.friends-list').appendChild(row);
    });
  }
  window.acceptRequest=async(docId)=>{ await updateDoc(doc(db,'friendships',docId),{status:'accepted'}); showToast('Friend added! 🎉','success'); await loadFriends(); };
  window.declineRequest=async(docId)=>{ await updateDoc(doc(db,'friendships',docId),{status:'declined'}); showToast('Declined.',''); await loadPendingRequests(); renderPendingView(); };

  window.sendFriendRequest=async function(){
    const input=document.getElementById('add-friend-input-modal'), rb=document.getElementById('add-friend-result-modal');
    const username=input.value.trim().toLowerCase(); rb.className='add-result';
    if (!username) { rb.textContent='Please enter a username.'; rb.className='add-result error'; return; }
    if (username===currentProfile.username) { rb.textContent="You can't add yourself!"; rb.className='add-result error'; return; }
    const usSnap=await getDoc(doc(db,'usernames',username));
    if (!usSnap.exists()) { rb.textContent=`No user found: "${username}".`; rb.className='add-result error'; return; }
    const targetUid=usSnap.data().uid;
    const tSnap=await getDoc(doc(db,'users',targetUid));
    if (tSnap.exists()&&tSnap.data().deleted) { rb.textContent='That account no longer exists.'; rb.className='add-result error'; return; }
    const existSnap=await getDocs(query(collection(db,'friendships'),where('users','array-contains',currentUser.uid)));
    for (const d of existSnap.docs) { if (d.data().users.includes(targetUid)) { rb.textContent=d.data().status==='accepted'?"Already friends!":'Request already sent.'; rb.className='add-result error'; return; } }
    await addDoc(collection(db,'friendships'),{users:[currentUser.uid,targetUid],from:currentUser.uid,to:targetUid,status:'pending',createdAt:serverTimestamp()});
    rb.textContent=`Request sent to @${username}! 🎉`; rb.className='add-result success'; input.value='';
  };

  // ── DM ──
  window.openDm = function(friend) {
    currentDmFriend=friend; currentServer=null; currentChannel=null;
    if (dmUnsubscribe) dmUnsubscribe();
    if (chUnsubscribe) chUnsubscribe();
    if (typingUnsubscribe) typingUnsubscribe();
    document.getElementById('profile-panel').classList.add('hidden');
    const name=friend.deleted?'Deleted User':(friend.displayName||friend.username);
    const vs=friend.deleted?'offline':visibleStatus(friend.status);
    // Build DM header with DOM nodes (no sj() inline onclick)
    const hdr=document.getElementById('main-header'); hdr.innerHTML='';
    const hamBtn2=document.createElement('button'); hamBtn2.className='hamburger'; hamBtn2.textContent='☰'; hamBtn2.onclick=toggleMobileSidebar; hdr.appendChild(hamBtn2);
    const dmAvEl=document.createElement('div');
    dmAvEl.style.cssText='width:34px;height:34px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;color:#fff;overflow:hidden;flex-shrink:0';
    dmAvEl.style.background=friend.deleted?'var(--muted)':color(friend.username);
    if(!friend.deleted) dmAvEl.style.cursor='pointer';
    dmAvEl.innerHTML=friend.avatarUrl&&!friend.deleted?`<img src="${friend.avatarUrl}" style="width:100%;height:100%;object-fit:cover"/>`:name[0].toUpperCase();
    if(!friend.deleted) dmAvEl.addEventListener('click',()=>showProfilePanel(friend));
    hdr.appendChild(dmAvEl);
    const dmTitle=document.createElement('h2'); dmTitle.textContent=name;
    if(!friend.deleted){dmTitle.style.cursor='pointer'; dmTitle.addEventListener('click',()=>showProfilePanel(friend));}
    hdr.appendChild(dmTitle);
    const dmStat=document.createElement('span'); dmStat.style.cssText='font-size:0.76rem;color:var(--muted)'; dmStat.textContent='· '+(friend.deleted?'Account deleted':statusLabel(vs)); hdr.appendChild(dmStat);
    if(!friend.deleted){
      const callBtn3=document.createElement('button'); callBtn3.className='friend-btn'; callBtn3.title='Call'; callBtn3.textContent='📞'; callBtn3.style.marginLeft='auto'; callBtn3.addEventListener('click',()=>window.startCall(friend)); hdr.appendChild(callBtn3);
      const ppBtn=document.createElement('button'); ppBtn.className='friend-btn'; ppBtn.title='Profile'; ppBtn.textContent='👤'; ppBtn.addEventListener('click',()=>showProfilePanel(friend)); hdr.appendChild(ppBtn);
    } else { const sp=document.createElement('span'); sp.style.marginLeft='auto'; hdr.appendChild(sp); }
    const content=document.getElementById('main-content');
    content.className='main-content chat-mode';
    content.innerHTML=`<div class="chat-view"><div class="chat-messages" id="chat-messages"></div><div class="typing-indicator" id="typing-indicator"></div>${friend.deleted?`<div class="deactivated-bar">⚠️ This account has been deactivated.</div>`:`<div class="chat-input-area"><div class="chat-input-box"><button class="chat-attach-btn" onclick="document.getElementById('dm-file-input').click()">📎</button><input type="text" id="chat-input" placeholder="Message @${name}" oninput="handleTypingDm()" onkeydown="if(event.key==='Enter')sendMessage()"/><button class="chat-send-btn" onclick="sendMessage()">➤</button></div></div>`}</div>`;

    const roomId=[currentUser.uid,friend.id].sort().join('_');
    let dmInitialLoad = true;
    dmUnsubscribe=onSnapshot(query(collection(db,'dms',roomId,'messages'),orderBy('createdAt')), snap => {
      const container=document.getElementById('chat-messages'); if(!container) return;
      container.innerHTML='';
      if (snap.empty) { container.innerHTML=`<div class="empty-state" style="flex:1"><div class="empty-icon">👋</div><h3>${friend.deleted?'Conversation history':'Start the conversation!'}</h3></div>`; dmInitialLoad=false; return; }
      snap.docs.forEach(d => renderMsg(d.data(), container, friend, d.id, `dms/${roomId}/messages`));
      container.scrollTop=container.scrollHeight;
      // Notification for new messages after initial load
      if (!dmInitialLoad) {
        const added = snap.docChanges().filter(c => c.type === 'added');
        const hasNewFromOther = added.some(c => c.doc.data().senderId !== currentUser.uid);
        if (hasNewFromOther) {
          playNotifSound();
          if (document.hidden) markUnread(friend.id);
        }
      }
      dmInitialLoad = false;
    });

    // Typing indicator listener
    if (!friend.deleted) {
      typingUnsubscribe=onSnapshot(doc(db,'typing',roomId), snap => {
        const data=snap.data()||{};
        const others=Object.entries(data).filter(([uid,v])=>uid!==currentUser.uid&&v===true);
        const ti=document.getElementById('typing-indicator'); if(!ti) return;
        if (others.length) { ti.innerHTML=`<strong>${esc(name)}</strong> is typing...<span class="typing-dots"><span></span><span></span><span></span></span>`; }
        else ti.innerHTML='';
      });
    }
  };

  function renderMsg(data, container, friendOrChannel, docId, collPath) {
    const isMe = data.senderId === currentUser.uid;
    const senderProfile = friendOrChannel || (!isMe && userCache[data.senderId]) || null;
    const senderIsDeletedUser = !isMe && senderProfile?.deleted;
    const sName = isMe ? (currentProfile.displayName || currentProfile.username) : (senderIsDeletedUser ? 'Deleted User' : (senderProfile?.displayName || senderProfile?.username || data.senderName || 'Unknown'));
    const sAvatar = isMe ? currentProfile.avatarUrl : (senderIsDeletedUser ? '' : senderProfile?.avatarUrl);
    const sColor = isMe ? color(currentProfile.username) : (senderIsDeletedUser ? 'var(--muted)' : color(senderProfile?.username || data.senderUsername || 'x'));
    const sData = isMe ? {...currentProfile, id: currentUser.uid} : senderProfile;
    const time = data.createdAt ? new Date(data.createdAt.toDate()).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : '';
    const editedTime = data.editedAt ? new Date(data.editedAt.toDate()).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : '';

    let roleBadgeHtml = '';
    if (data.senderRoleName && data.senderRoleColor) {
      roleBadgeHtml = `<span class="role-badge" style="background:${data.senderRoleColor}22;color:${data.senderRoleColor}">${esc(data.senderRoleName)}</span>`;
    }

    const el = document.createElement('div');
    el.className = 'chat-msg';
    el.dataset.msgId = docId || '';

    // Avatar
    const avatarEl = document.createElement('div');
    avatarEl.className = 'chat-msg-avatar';
    avatarEl.style.background = sColor;
    avatarEl.innerHTML = sAvatar ? `<img src="${sAvatar}"/>` : (sName[0] || '?').toUpperCase();
    if (sData && !senderIsDeletedUser) avatarEl.style.cursor = 'pointer';

    // Body
    const bodyEl = document.createElement('div');
    bodyEl.className = 'chat-msg-body';

    // Header row
    const headerEl = document.createElement('div');
    headerEl.className = 'chat-msg-header';
    if (roleBadgeHtml) { const rb = document.createElement('span'); rb.innerHTML = roleBadgeHtml; headerEl.appendChild(rb); }
    const nameSpan = document.createElement('span');
    nameSpan.className = 'chat-msg-name';
    nameSpan.textContent = sName;
    if (sData && !senderIsDeletedUser) nameSpan.style.cursor = 'pointer';
    const timeSpan = document.createElement('span');
    timeSpan.className = 'chat-msg-time';
    timeSpan.textContent = time;
    if (data.editedAt) {
      const editedTag = document.createElement('span');
      editedTag.className = 'msg-edited-tag';
      editedTag.textContent = `(edited ${editedTime})`;
      timeSpan.appendChild(editedTag);
    }
    headerEl.appendChild(nameSpan);
    headerEl.appendChild(timeSpan);

    // Message body content
    const bodyContent = document.createElement('div');
    bodyContent.className = 'msg-body-content';
    if (data.type === 'image') bodyContent.innerHTML = `<img class="msg-image" src="${data.fileUrl}" alt="" onclick="openLightbox('${data.fileUrl}')"/>`;
    else if (data.type === 'video') bodyContent.innerHTML = `<video class="msg-video" controls src="${data.fileUrl}"></video>`;
    else if (data.type === 'audio') bodyContent.innerHTML = `<audio class="msg-audio" controls src="${data.fileUrl}"></audio>`;
    else if (data.type === 'file') bodyContent.innerHTML = `<a class="msg-file" href="${data.fileUrl}" target="_blank"><span class="msg-file-icon">${fileIcon(data.fileName||'')}</span><div><div class="msg-file-name">${esc(data.fileName||'File')}</div><div class="msg-file-size">${data.fileSize||''} · Download</div></div></a>`;
    else bodyContent.innerHTML = `<div class="chat-msg-text">${esc(data.text||'')}</div>`;

    bodyEl.appendChild(headerEl);
    bodyEl.appendChild(bodyContent);
    el.appendChild(avatarEl);
    el.appendChild(bodyEl);

    // Message action buttons
    const canDelete = isMe || isAdmin;
    const canEdit = isMe && data.type === 'text';
    if (docId && collPath) {
      const actionsEl = document.createElement('div');
      actionsEl.className = 'msg-actions';
      if (canEdit) {
        const editBtn = document.createElement('button');
        editBtn.className = 'msg-action-btn';
        editBtn.textContent = '✏️ Edit';
        editBtn.addEventListener('click', () => startEditMsg(el, bodyContent, data, docId, collPath));
        actionsEl.appendChild(editBtn);
      }
      if (canDelete) {
        const delBtn = document.createElement('button');
        delBtn.className = 'msg-action-btn delete';
        delBtn.textContent = '🗑️ Delete';
        delBtn.addEventListener('click', async () => {
          if (!confirm('Delete this message?')) return;
          try { await deleteDoc(doc(db, collPath, docId)); showToast('Message deleted', ''); }
          catch(e) { showToast('Could not delete: ' + e.message, 'error'); }
        });
        actionsEl.appendChild(delBtn);
      }
      // Report button — always visible on others' messages
      if (!isMe) {
        const repBtn = document.createElement('button');
        repBtn.className = 'msg-action-btn';
        repBtn.textContent = '🚩 Report';
        repBtn.addEventListener('click', () => openMsgReport(data, docId, collPath, sName));
        actionsEl.appendChild(repBtn);
      }
      el.appendChild(actionsEl);
    }

    if (sData && !senderIsDeletedUser) {
      avatarEl.addEventListener('click', () => showProfilePanel(sData));
      nameSpan.addEventListener('click', () => showProfilePanel(sData));
    }

    // Reaction picker (quick emoji bar on hover)
    if (docId && collPath) {
      const picker = document.createElement('div'); picker.className = 'reaction-picker';
      ['👍','❤️','😂','😮','😢','🔥','🎉','💯'].forEach(emoji => {
        const btn = document.createElement('span'); btn.className = 'reaction-emoji'; btn.textContent = emoji;
        btn.addEventListener('click', e => { e.stopPropagation(); addReaction(collPath, docId, emoji); });
        picker.appendChild(btn);
      });
      el.appendChild(picker);
      // Existing reactions display
      if (data.reactions && Object.keys(data.reactions).length) {
        const reactionsEl = document.createElement('div'); reactionsEl.className = 'msg-reactions';
        renderReactions(reactionsEl, data.reactions, collPath, docId);
        bodyEl.appendChild(reactionsEl);
      }
    }

    container.appendChild(el);
  }

  function renderReactions(container, reactions, collPath, docId) {
    container.innerHTML = '';
    // reactions = { emoji: { uid1: true, uid2: true, ... } }
    Object.entries(reactions).forEach(([emoji, users]) => {
      const uids = Object.keys(users);
      if (!uids.length) return;
      const pill = document.createElement('button'); pill.className = 'reaction-pill';
      if (users[currentUser.uid]) pill.classList.add('reacted');
      pill.innerHTML = `${emoji} <span class="r-count">${uids.length}</span>`;
      pill.title = uids.map(uid => userCache[uid]?.displayName || userCache[uid]?.username || uid).join(', ');
      pill.addEventListener('click', () => addReaction(collPath, docId, emoji));
      container.appendChild(pill);
    });
  }

  async function addReaction(collPath, docId, emoji) {
    const msgRef = doc(db, collPath, docId);
    const reactionPath = `reactions.${emoji}.${currentUser.uid}`;
    try {
      const snap = await getDoc(msgRef);
      if (!snap.exists()) return;
      const existing = snap.data().reactions?.[emoji]?.[currentUser.uid];
      if (existing) {
        // Remove reaction
        const update = {}; update[reactionPath] = false;
        await updateDoc(msgRef, update);
      } else {
        // Add reaction
        const update = {}; update[reactionPath] = true;
        await updateDoc(msgRef, update);
      }
    } catch(e) { console.warn('Reaction error', e); }
  }

  function startEditMsg(el, bodyContent, data, docId, collPath) {
    // Replace body content with edit input
    bodyContent.innerHTML = '';
    const editArea = document.createElement('div');
    editArea.className = 'msg-edit-area';
    const inp = document.createElement('input');
    inp.className = 'msg-edit-input';
    inp.type = 'text';
    inp.value = data.text || '';
    const saveBtn = document.createElement('button');
    saveBtn.className = 'msg-action-btn';
    saveBtn.textContent = 'Save';
    saveBtn.style.background = 'var(--accent)';
    saveBtn.style.color = '#fff';
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'msg-action-btn';
    cancelBtn.textContent = 'Cancel';
    editArea.appendChild(inp);
    editArea.appendChild(saveBtn);
    editArea.appendChild(cancelBtn);
    bodyContent.appendChild(editArea);
    inp.focus();

    const doSave = async () => {
      const newText = inp.value.trim();
      if (!newText) return;
      try {
        await updateDoc(doc(db, collPath, docId), {
          text: newText,
          editedAt: serverTimestamp(),
        });
        // Snapshot will re-render, no manual DOM update needed
      } catch(e) { showToast('Edit failed: ' + e.message, 'error'); }
    };
    saveBtn.addEventListener('click', doSave);
    cancelBtn.addEventListener('click', () => {
      bodyContent.innerHTML = `<div class="chat-msg-text">${esc(data.text || '')}</div>`;
    });
    inp.addEventListener('keydown', e => {
      if (e.key === 'Enter') doSave();
      if (e.key === 'Escape') cancelBtn.click();
    });
  }
  window.sendMessage=async function(){
    const input=document.getElementById('chat-input'); const text=input?.value.trim();
    if (!text||!currentDmFriend||currentDmFriend.deleted) return;
    input.value='';
    clearTypingDm();
    const roomId=[currentUser.uid,currentDmFriend.id].sort().join('_');
    await addDoc(collection(db,'dms',roomId,'messages'),{text,senderId:currentUser.uid,type:'text',createdAt:serverTimestamp()});
  };

  // DM typing
  function handleTypingDm() {
    if (!currentDmFriend) return;
    const roomId=[currentUser.uid,currentDmFriend.id].sort().join('_');
    setDoc(doc(db,'typing',roomId),{[currentUser.uid]:true},{merge:true}).catch(()=>{});
    clearTimeout(typingTimeout);
    typingTimeout=setTimeout(()=>clearTypingDm(),3000);
  }
  function clearTypingDm() {
    if (!currentDmFriend) return;
    const roomId=[currentUser.uid,currentDmFriend.id].sort().join('_');
    setDoc(doc(db,'typing',roomId),{[currentUser.uid]:false},{merge:true}).catch(()=>{});
  }

  // ── FILE UPLOAD (DM) ──
  window.handleDmFileUpload=async function(event){ await uploadAndSend(event,'dm'); };
  window.handleChFileUpload=async function(event){ await uploadAndSend(event,'channel'); };

  async function uploadAndSend(event, mode) {
    const file=event.target.files[0]; event.target.value='';
    if (!file) return;
    const target=mode==='dm'?currentDmFriend:currentChannel;
    if (!target) return;
    if (file.size>100*1024*1024) { showToast('File must be under 100MB','error'); return; }
    const container=document.getElementById('chat-messages');
    const indicator=document.createElement('div'); indicator.className='upload-progress';
    indicator.innerHTML=`<span>⬆️ Uploading ${esc(file.name)}...</span><div class="progress-bar"><div class="progress-fill" id="upload-fill"></div></div>`;
    if (container) { container.appendChild(indicator); container.scrollTop=container.scrollHeight; }
    try {
      const fd=new FormData(); fd.append('file',file); fd.append('upload_preset',CLOUDINARY_PRESET); fd.append('resource_type','auto');
      let prog=0;
      const iv=setInterval(()=>{ prog=Math.min(prog+8,85); const el=document.getElementById('upload-fill'); if(el) el.style.width=prog+'%'; },200);
      const res=await fetch(`https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD}/auto/upload`,{method:'POST',body:fd});
      const data=await res.json(); clearInterval(iv);
      if (indicator.parentNode) indicator.remove();
      if (!data.secure_url) throw new Error();
      let ftype='file';
      if (file.type.startsWith('image/')) ftype='image';
      else if (file.type.startsWith('video/')) ftype='video';
      else if (file.type.startsWith('audio/')) ftype='audio';
      if (mode==='dm') {
        const roomId=[currentUser.uid,currentDmFriend.id].sort().join('_');
        await addDoc(collection(db,'dms',roomId,'messages'),{senderId:currentUser.uid,type:ftype,fileUrl:data.secure_url,fileName:file.name,fileSize:fmtSize(file.size),createdAt:serverTimestamp()});
      } else {
        await sendChannelMsg(null, ftype, data.secure_url, file.name, fmtSize(file.size));
      }
    } catch { if(indicator.parentNode) indicator.remove(); showToast('Upload failed.','error'); }
  }

  window.openLightbox=url=>{ document.getElementById('lightbox-img').src=url; document.getElementById('lightbox').classList.add('open'); };

  // ══════════════════════════════════════
  // ── SERVERS ──
  // ══════════════════════════════════════
  window.showServerOptions = function() {
    // Show create or join options
    const menu = document.createElement('div');
    menu.id = 'server-options-menu';
    menu.style.cssText = `position:fixed;z-index:500;background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:8px;box-shadow:0 8px 32px rgba(0,0,0,0.5);min-width:180px`;
    // Position near add button
    const btn = document.getElementById('add-server-btn');
    const rect = btn.getBoundingClientRect();
    menu.style.left = (rect.right + 8) + 'px';
    menu.style.top = rect.top + 'px';
    menu.innerHTML = `
      <div onclick="closeServerOptionsMenu();openModal('createServerModal')" style="padding:10px 14px;cursor:pointer;border-radius:8px;font-size:0.88rem;display:flex;align-items:center;gap:8px;transition:background 0.15s" onmouseover="this.style.background='var(--surface2)'" onmouseout="this.style.background=''">➕ Create Server</div>
      <div onclick="closeServerOptionsMenu();openModal('joinServerModal')" style="padding:10px 14px;cursor:pointer;border-radius:8px;font-size:0.88rem;display:flex;align-items:center;gap:8px;transition:background 0.15s" onmouseover="this.style.background='var(--surface2)'" onmouseout="this.style.background=''">🔗 Join via Invite</div>`;
    document.body.appendChild(menu);
    setTimeout(()=>document.addEventListener('click', closeServerOptionsMenu, {once:true}), 10);
  };
  window.closeServerOptionsMenu=()=>{ const m=document.getElementById('server-options-menu'); if(m) m.remove(); };

  async function loadServers() {
    try {
      // Query both owned servers and servers the user is a member of
      const [ownedSnap, memberSnap] = await Promise.all([
        getDocs(query(collection(db,'servers'), where('ownerId','==',currentUser.uid))),
        getDocs(query(collection(db,'serverMembers'), where('userId','==',currentUser.uid)))
      ]);

      // Build list deduplicated by document ID
      const seen = new Set();
      const allServers = [];
      ownedSnap.docs.forEach(d => {
        if (!seen.has(d.id)) { seen.add(d.id); allServers.push({id:d.id,...d.data()}); }
      });
      for (const m of memberSnap.docs) {
        const sid = m.data().serverId;
        if (sid && !seen.has(sid)) {
          const ss = await getDoc(doc(db,'servers',sid));
          if (ss.exists()) { seen.add(sid); allServers.push({id:sid,...ss.data()}); }
        }
      }

      window._servers = allServers;

      // Re-render the sidebar icons (clear first to avoid duplicates)
      const bar = document.getElementById('servers-bar');
      bar.querySelectorAll('.server-icon.user-server').forEach(e => e.remove());
      const before = bar.querySelector('.server-icon.add');
      allServers.forEach(data => {
        const icon = document.createElement('div');
        icon.className = 'server-icon user-server';
        icon.style.cssText = `background:${color(data.name)};color:#fff`;
        icon.title = data.name;
        icon.innerHTML = `<span class="server-pip"></span>${data.name[0].toUpperCase()}`;
        icon.onclick = () => {
          document.querySelectorAll('.server-icon').forEach(i => i.classList.remove('active'));
          icon.classList.add('active');
          window.openServer(window._servers.find(s=>s.id===data.id) || data);
        };
        bar.insertBefore(icon, before);
      });
    } catch(e) {
      console.error('loadServers error:', e);
    }
  }

  let _creatingServer = false;
  window.createServer=async function(){
    if (_creatingServer) return;   // prevent double-tap duplication
    const name=document.getElementById('server-name-input').value.trim();
    if (!name) { showToast('Enter a server name','error'); return; }
    _creatingServer = true;
    try {
    const serverRef=await addDoc(collection(db,'servers'),{name,ownerId:currentUser.uid,createdAt:serverTimestamp()});
    // Create default general channel
    await addDoc(collection(db,'channels'),{name:'general',serverId:serverRef.id,type:'text',permissions:{view:'everyone',send:'everyone'},createdAt:serverTimestamp()});
    // Add owner as member with 'Owner' role
    await setDoc(doc(db,'serverMembers',`${serverRef.id}_${currentUser.uid}`),{serverId:serverRef.id,userId:currentUser.uid,role:'owner',joinedAt:serverTimestamp()});
    document.getElementById('server-name-input').value='';
    closeModal('createServerModal'); showToast(`Server "${name}" created! 🎉`,'success');
    await loadServers();
    // Auto-open the new server and jump straight into #general
    const newServerData = { id: serverRef.id, name, ownerId: currentUser.uid };
    await window.openServer(newServerData);
    } catch(e) { showToast('Error creating server: '+e.message,'error'); }
    finally { _creatingServer = false; }
  };

  window.openServer = async function openServer(serverData) {
    try {
    currentServer=serverData; currentChannel=null; currentDmFriend=null;
    if (dmUnsubscribe) dmUnsubscribe();
    if (chUnsubscribe) chUnsubscribe();
    if (typingUnsubscribe) typingUnsubscribe();
    document.getElementById('profile-panel').classList.add('hidden');

    // Check if user is owner or has admin role
    const isOwner=serverData.ownerId===currentUser.uid;
    const memberSnap=await getDoc(doc(db,'serverMembers',`${serverData.id}_${currentUser.uid}`));
    const memberData=memberSnap.exists()?memberSnap.data():{};

    // Load member's assigned role if any
    let memberRoleData=null;
    if (memberData.assignedRoleId) {
      const rSnap=await getDoc(doc(db,'roles',memberData.assignedRoleId));
      if (rSnap.exists()) memberRoleData={id:rSnap.id,...rSnap.data()};
    }
    window._myServerRole=memberRoleData;
    window._isServerOwner=isOwner;
    const canManage=isOwner||(memberRoleData?.permissions?.admin);

    // Load channels
    const channelsSnap=await getDocs(query(collection(db,'channels'),where('serverId','==',serverData.id)));
    const channels=channelsSnap.docs.map(d=>({id:d.id,...d.data()}));
    window._serverChannels=channels;

    // Render sidebar
    document.getElementById('sidebar-title').textContent='# '+serverData.name;
    const actionBtn=document.getElementById('sidebar-action-btn');
    if (canManage) {
      actionBtn.innerHTML='⚙️'; actionBtn.title='Server Settings';
      actionBtn.onclick=()=>showServerSettings(serverData,channels);
    } else {
      actionBtn.innerHTML='🔗'; actionBtn.title='Invite'; actionBtn.onclick=()=>openInviteModal(serverData);
    }

    const scroll=document.getElementById('sidebar-scroll'); scroll.innerHTML='';
    // Split text and voice channels
    const textChannels = channels.filter(ch => ch.type !== 'voice');
    const voiceChannels = channels.filter(ch => ch.type === 'voice');

    // TEXT CHANNELS
    const chLabel=document.createElement('div'); chLabel.className='sidebar-section-label';
    chLabel.innerHTML=`TEXT CHANNELS${canManage?`<button class="sl-btn" onclick="addChannel('${serverData.id}')" title="Add Text Channel">+</button>`:''}`;
    scroll.appendChild(chLabel);
    textChannels.forEach(ch => {
      const canView=canViewChannel(ch,memberRoleData,isOwner);
      if (!canView) return;
      const div=document.createElement('div'); div.className='channel-item'; div.id='ch-'+ch.id;
      const locked=ch.permissions?.view!=='everyone'&&!isOwner;
      div.innerHTML=`<span style="color:var(--muted);font-size:0.9rem">#</span><span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${esc(ch.name)}</span>${locked?`<span class="ch-lock">🔒</span>`:''}${canManage?`<button style="background:none;border:none;color:var(--muted);cursor:pointer;font-size:0.8rem;padding:2px 4px;border-radius:4px" onclick="event.stopPropagation();openChannelPerms('${ch.id}','${esc(ch.name)}','${serverData.id}')" title="Permissions">⚙</button>`:''}`;
      div.onclick=()=>{ document.querySelectorAll('.channel-item').forEach(c=>c.classList.remove('active')); div.classList.add('active'); openChannel(ch,serverData,memberRoleData,isOwner); closeMobileSidebar(); };
      scroll.appendChild(div);
    });

    // VOICE CHANNELS
    const vcLabel=document.createElement('div'); vcLabel.className='sidebar-section-label';
    vcLabel.innerHTML=`VOICE CHANNELS${canManage?`<button class="sl-btn" onclick="addVoiceChannel('${serverData.id}')" title="Add Voice Channel">+</button>`:''}`;
    scroll.appendChild(vcLabel);
    if (!voiceChannels.length) {
      const empty=document.createElement('div'); empty.style.cssText='padding:2px 16px 6px;font-size:0.76rem;color:var(--muted)';
      empty.textContent=canManage?'No voice channels — click + to add':'No voice channels';
      scroll.appendChild(empty);
    }
    voiceChannels.forEach(ch => {
      const div=document.createElement('div'); div.className='voice-channel-item'; div.id='vc-'+ch.id;
      div.innerHTML=`<span style="font-size:1rem">🔊</span><span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${esc(ch.name)}</span>`;
      div.onclick=()=>{ window.joinVoiceChannel(ch, serverData); };
      scroll.appendChild(div);
      // Show current participants if any
      getDocs(collection(db,'voicePresence',ch.id,'members')).then(snap=>{
        if(snap.size>0) updateVoiceChannelUI(ch.id, snap.docs.map(d=>d.data()));
      }).catch(()=>{});
    });

    // Members section
    const memLabel=document.createElement('div'); memLabel.className='sidebar-section-label';
    memLabel.innerHTML='MEMBERS';
    scroll.appendChild(memLabel);
    const membersSnap=await getDocs(query(collection(db,'serverMembers'),where('serverId','==',serverData.id)));
    for (const m of membersSnap.docs) {
      const mData=m.data();
      const uSnap=await getDoc(doc(db,'users',mData.userId));
      if (!uSnap.exists()||uSnap.data().deleted) continue;
      const u={id:mData.userId,...uSnap.data()};
      const mName=u.displayName||u.username;
      const isMe=u.id===currentUser.uid;
      // Get role
      let roleInfo=null;
      if (mData.assignedRoleId) { const rSnap=await getDoc(doc(db,'roles',mData.assignedRoleId)); if(rSnap.exists()) roleInfo={id:rSnap.id,...rSnap.data()}; }
      const div=document.createElement('div'); div.className='sidebar-item';
      div.innerHTML=`<div class="item-avatar" style="background:${color(u.username)}">${u.avatarUrl?`<img src="${u.avatarUrl}"/>`:mName[0].toUpperCase()}<span class="status-dot ${visibleStatus(u.status)}"></span></div><div style="flex:1;min-width:0"><div style="font-size:0.84rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${mName}${isMe?' (you)':''}</div>${roleInfo?`<div style="font-size:0.68rem;color:${roleInfo.color||'var(--muted)'}">${esc(roleInfo.name)}</div>`:''}</div>`;
      div.onclick=()=>showProfilePanel(u);
      scroll.appendChild(div);
    }

    // Expose currentServer globally
    window.currentServer = serverData;

    // If there are visible channels, auto-open the first one immediately
    const firstVisibleChannel = channels.find(ch => ch.type !== 'voice' && canViewChannel(ch, memberRoleData, isOwner));
    if (firstVisibleChannel) {
      // Mark it active in sidebar
      const firstDiv = document.getElementById('ch-' + firstVisibleChannel.id);
      if (firstDiv) { document.querySelectorAll('.channel-item').forEach(c=>c.classList.remove('active')); firstDiv.classList.add('active'); }
      await openChannel(firstVisibleChannel, serverData, memberRoleData, isOwner);
    } else {
      // No channels yet - show landing page
      const hdr=document.getElementById('main-header');
      hdr.innerHTML='';
      const hamBtn=document.createElement('button'); hamBtn.className='hamburger'; hamBtn.textContent='☰'; hamBtn.onclick=toggleMobileSidebar; hdr.appendChild(hamBtn);
      const hashSpan=document.createElement('span'); hashSpan.textContent='🏰'; hdr.appendChild(hashSpan);
      const titleH=document.createElement('h2'); titleH.textContent=serverData.name; hdr.appendChild(titleH);
      const actDiv=document.createElement('div'); actDiv.style.marginLeft='auto'; actDiv.style.display='flex'; actDiv.style.gap='6px';
      if (canManage) {
        const invBtn=document.createElement('button'); invBtn.className='friend-btn'; invBtn.title='Invite'; invBtn.textContent='🔗'; invBtn.onclick=()=>openInviteModal(window.currentServer); actDiv.appendChild(invBtn);
        const roleBtn=document.createElement('button'); roleBtn.className='friend-btn'; roleBtn.title='Roles'; roleBtn.textContent='🎭'; roleBtn.onclick=()=>{openModal('rolesModal');loadRolesModal(window.currentServer.id);}; actDiv.appendChild(roleBtn);
      } else {
        const invBtn=document.createElement('button'); invBtn.className='friend-btn'; invBtn.title='Invite'; invBtn.textContent='🔗'; invBtn.onclick=()=>openInviteModal(window.currentServer); actDiv.appendChild(invBtn);
      }
      hdr.appendChild(actDiv);
      const mc=document.getElementById('main-content'); mc.className='main-content';
      mc.innerHTML=`<div class="empty-state"><div class="empty-icon">💬</div><h3>${esc(serverData.name)}</h3><p>No channels yet.${canManage?' Use the sidebar to add one.':''}</p></div>`;
    }
  } catch(err) { console.error('openServer error:', err); showToast('Error loading server: '+err.message, 'error'); }
  };

  function canViewChannel(ch, roleData, isOwner) {
    if (isOwner) return true;
    if (roleData?.permissions?.admin) return true;
    if (!ch.permissions||ch.permissions.view==='everyone') return true;
    if (ch.permissions.view==='role'&&roleData&&ch.permissions.viewRoleId===roleData.id) return true;
    return false;
  }
  function canSendInChannel(ch, roleData, isOwner) {
    if (isOwner) return true;
    if (roleData?.permissions?.admin) return true;
    if (!ch.permissions||ch.permissions.send==='everyone') return true;
    if (ch.permissions.send==='role'&&roleData&&ch.permissions.sendRoleId===roleData.id) return true;
    if (roleData?.permissions?.send===false) return false;
    return true;
  }

  async function openChannel(ch, serverData, memberRoleData, isOwner) {
    currentChannel=ch; currentDmFriend=null;
    if (chUnsubscribe) chUnsubscribe();
    if (dmUnsubscribe) dmUnsubscribe();
    if (typingUnsubscribe) typingUnsubscribe();
    const canSend=canSendInChannel(ch,memberRoleData,isOwner);
    const canManage=isOwner||(memberRoleData?.permissions?.admin);

    document.getElementById('main-header').innerHTML=`<button class="hamburger" onclick="toggleMobileSidebar()">☰</button><span style="color:var(--muted)">#</span><h2>${esc(ch.name)}</h2>${canManage?`<button style="margin-left:auto" class="friend-btn" onclick="openInviteModal(currentServer)" title="Invite">🔗</button>`:''}`;
    const content=document.getElementById('main-content');
    content.className='main-content chat-mode';
    content.innerHTML=`<div class="chat-view"><div class="chat-messages" id="chat-messages"></div><div class="typing-indicator" id="typing-indicator"></div>${canSend?`<div class="chat-input-area"><div class="chat-input-box"><button class="chat-attach-btn" onclick="document.getElementById('ch-file-input').click()">📎</button><input type="text" id="chat-input" placeholder="Message #${esc(ch.name)}" oninput="handleTypingChannel()" onkeydown="if(event.key==='Enter')sendChannelMsg()"/><button class="chat-send-btn" onclick="sendChannelMsg()">➤</button></div></div>`:`<div class="no-perm-bar">🔒 You don't have permission to send messages in this channel.</div>`}</div>`;

    chUnsubscribe=onSnapshot(query(collection(db,'channels',ch.id,'messages'),orderBy('createdAt')), async snap=>{
      const container=document.getElementById('chat-messages'); if(!container) return;
      container.innerHTML='';
      if (snap.empty) { container.innerHTML=`<div class="empty-state" style="flex:1"><div class="empty-icon">👋</div><h3>Welcome to #${esc(ch.name)}!</h3><p>This is the beginning of this channel.</p></div>`; return; }
      // Fetch any uncached sender profiles first
      const senderIds=[...new Set(snap.docs.map(d=>d.data().senderId).filter(id=>id&&id!==currentUser.uid&&!userCache[id]))];
      await Promise.all(senderIds.map(async id=>{
        try { const s=await getDoc(doc(db,'users',id)); if(s.exists()) userCache[id]={id,...s.data()}; } catch(e){}
      }));
      snap.docs.forEach(d=>renderMsg(d.data(),container,null,d.id,`channels/${ch.id}/messages`));
      container.scrollTop=container.scrollHeight;
    });

    // Typing — show up to 3 names, then "multiple people"
    typingUnsubscribe=onSnapshot(doc(db,'typing','ch_'+ch.id), snap=>{
      const data=snap.data()||{};
      const others=Object.keys(data).filter(uid=>uid!==currentUser.uid&&data[uid]===true);
      const ti=document.getElementById('typing-indicator'); if(!ti) return;
      if (!others.length) { ti.innerHTML=''; return; }
      const names=others.map(uid=>{
        const u=userCache[uid];
        return u?(u.displayName||u.username):null;
      }).filter(Boolean);
      let txt;
      if (others.length > 3) {
        txt='<strong>Multiple people</strong> are typing...';
      } else if (names.length===0) {
        txt=`<strong>${others.length===1?'Someone':'Several people'}</strong> ${others.length===1?'is':'are'} typing...`;
      } else if (names.length===1) {
        txt=`<strong>${esc(names[0])}</strong> is typing...`;
      } else if (names.length===2) {
        txt=`<strong>${esc(names[0])}</strong> and <strong>${esc(names[1])}</strong> are typing...`;
      } else {
        txt=`<strong>${esc(names[0])}</strong>, <strong>${esc(names[1])}</strong>, and <strong>${esc(names[2])}</strong> are typing...`;
      }
      ti.innerHTML=txt+'<span class="typing-dots"><span></span><span></span><span></span></span>';
    });
  }

  async function sendChannelMsg(text=null, ftype=null, fileUrl=null, fileName=null, fileSize=null) {
    if (!currentChannel) return;
    const input=document.getElementById('chat-input');
    const msgText=text||(input?.value.trim());
    if (!msgText&&!fileUrl) return;
    if (input) input.value='';
    clearTypingChannel();
    const msgData={ senderId:currentUser.uid, senderName:currentProfile.displayName||currentProfile.username, senderUsername:currentProfile.username, senderAvatar:currentProfile.avatarUrl||'', type:ftype||'text', createdAt:serverTimestamp() };
    if (fileUrl) { msgData.fileUrl=fileUrl; msgData.fileName=fileName; msgData.fileSize=fileSize; }
    else msgData.text=msgText;
    // Attach role info
    if (window._myServerRole) { msgData.senderRoleName=window._myServerRole.name; msgData.senderRoleColor=window._myServerRole.color||'#5b6af0'; }
    await addDoc(collection(db,'channels',currentChannel.id,'messages'),msgData);
  }
  window.sendChannelMsg=sendChannelMsg;

  function handleTypingChannel() {
    if (!currentChannel) return;
    setDoc(doc(db,'typing','ch_'+currentChannel.id),{[currentUser.uid]:true},{merge:true}).catch(()=>{});
    clearTimeout(typingTimeout);
    typingTimeout=setTimeout(()=>clearTypingChannel(),3000);
  }
  function clearTypingChannel() {
    if (!currentChannel) return;
    setDoc(doc(db,'typing','ch_'+currentChannel.id),{[currentUser.uid]:false},{merge:true}).catch(()=>{});
  }

  async function addChannel(serverId) {
    const name=prompt('Channel name:'); if(!name) return;
    await addDoc(collection(db,'channels'),{name:name.toLowerCase().replace(/\s+/g,'-'),serverId,type:'text',permissions:{view:'everyone',send:'everyone'},createdAt:serverTimestamp()});
    if (currentServer) await window.openServer(currentServer);
  }
  window.addChannel=addChannel;

  // ── INVITE LINKS ──
  window.openInviteModal=function(server){
    if (!server) return;
    currentInviteServerData=server;
    document.getElementById('invite-server-name').textContent='Server: '+server.name;
    document.getElementById('invite-link-display').style.display='none';
    document.getElementById('invite-link-text').textContent='';
    openModal('inviteModal');
  };

  window.generateInvite=async function(){
    if (!currentInviteServerData) return;
    const expiry=document.getElementById('invite-expiry').value;
    const code=Math.random().toString(36).substring(2,9);
    let expiresAt=null;
    if (expiry==='1') expiresAt=new Date(Date.now()+86400000);
    else if (expiry==='7') expiresAt=new Date(Date.now()+604800000);
    await setDoc(doc(db,'invites',code),{serverId:currentInviteServerData.id,serverName:currentInviteServerData.name,createdBy:currentUser.uid,createdAt:serverTimestamp(),expiresAt,uses:0});
    const link=`${BASE_URL}dashboard.html?invite=${code}`;
    document.getElementById('invite-link-text').textContent=link;
    document.getElementById('invite-link-display').style.display='block';
    document.getElementById('invite-expiry-note').textContent=expiry==='never'?'This link never expires.':`This link expires in ${expiry==='1'?'1 day':'7 days'}.`;
  };

  window.copyInviteLink=function(){
    const text=document.getElementById('invite-link-text').textContent;
    navigator.clipboard.writeText(text).then(()=>showToast('Link copied!','success')).catch(()=>showToast('Copy manually from the box above',''));
  };

  window.joinServerViaInvite=async function(){
    const val=document.getElementById('join-invite-input').value.trim();
    const rb=document.getElementById('join-result'); rb.className='add-result';
    // extract code from URL or use as-is
    const code=val.includes('?invite=')? val.split('?invite=')[1] : val;
    if (!code) { rb.textContent='Please enter an invite link or code.'; rb.className='add-result error'; return; }
    await handleInviteFromUrl(code, rb);
  };

  async function handleInviteFromUrl(code, rb=null) {
    const invSnap=await getDoc(doc(db,'invites',code));
    if (!invSnap.exists()) { if(rb){rb.textContent='Invalid invite link.';rb.className='add-result error';} else showToast('Invalid invite link.','error'); return; }
    const inv=invSnap.data();
    // Check expiry
    if (inv.expiresAt) {
      const exp=inv.expiresAt.toDate?inv.expiresAt.toDate():new Date(inv.expiresAt);
      if (new Date()>exp) { if(rb){rb.textContent='This invite has expired.';rb.className='add-result error';} else showToast('Invite has expired.','error'); return; }
    }
    // Check if already member
    const memSnap=await getDoc(doc(db,'serverMembers',`${inv.serverId}_${currentUser.uid}`));
    if (memSnap.exists()) { if(rb){rb.textContent="You're already in this server!";rb.className='add-result error';} else { showToast("You're already in that server!",''); if(rb===null){closeModal('joinServerModal');} } return; }
    // Join
    await setDoc(doc(db,'serverMembers',`${inv.serverId}_${currentUser.uid}`),{serverId:inv.serverId,userId:currentUser.uid,role:'member',joinedAt:serverTimestamp()});
    await updateDoc(doc(db,'invites',code),{uses:(inv.uses||0)+1});
    if(rb){rb.textContent=`Joined "${inv.serverName}"! 🎉`;rb.className='add-result success';}
    showToast(`Joined "${inv.serverName}"! 🎉`,'success');
    closeModal('joinServerModal');
    await loadServers();
    // Remove invite param from URL
    window.history.replaceState({}, '', 'dashboard.html');
  }

  // ── ROLES ──
  window.loadRolesModal=async function(serverId){
    window._currentRolesServerId=serverId;
    showRolesTab('list');
    const snap=await getDocs(query(collection(db,'roles'),where('serverId','==',serverId)));
    window._serverRoles=snap.docs.map(d=>({id:d.id,...d.data()}));
    renderRolesList();
    // Setup color picker
    document.querySelectorAll('.role-color-swatch').forEach(s=>{
      s.onclick=()=>{ document.querySelectorAll('.role-color-swatch').forEach(x=>x.style.border='3px solid transparent'); s.style.border='3px solid #fff'; selectedRoleColor=s.dataset.color; };
    });
  };

  function renderRolesList(){
    const container=document.getElementById('roles-list-container');
    const roles=window._serverRoles||[];
    if (!roles.length) { container.innerHTML='<div style="color:var(--muted);font-size:0.86rem;text-align:center;padding:20px">No roles yet. Create one!</div>'; return; }
    container.innerHTML='';
    roles.forEach(r=>{
      const row=document.createElement('div'); row.className='role-row';
      const perms=Object.entries(r.permissions||{}).filter(([k,v])=>v===true).map(([k])=>k).join(', ')||'none';
      row.innerHTML=`<div class="role-color-dot" style="background:${r.color||'#5b6af0'}"></div><div class="role-name">${esc(r.name)}</div><div class="role-perms">${perms}</div><button class="role-del-btn" onclick="deleteRole('${r.id}')">🗑</button>`;
      container.appendChild(row);
    });
  }

  window.showRolesTab=function(tab){
    document.getElementById('roles-tab-list').style.display=tab==='list'?'block':'none';
    document.getElementById('roles-tab-create').style.display=tab==='create'?'block':'none';
    document.getElementById('roles-tab-members').style.display=tab==='members'?'block':'none';
    if (tab==='members') loadMembersForRoles();
  };

  window.createRole=async function(){
    const name=document.getElementById('new-role-name').value.trim();
    if (!name) { showToast('Enter a role name','error'); return; }
    const perms={
      admin:document.getElementById('perm-admin').checked,
      manageRoles:document.getElementById('perm-manage-roles').checked,
      send:document.getElementById('perm-send').checked,
      view:document.getElementById('perm-view').checked,
      files:document.getElementById('perm-files').checked
    };
    const serverId=window._currentRolesServerId;
    await addDoc(collection(db,'roles'),{name,color:selectedRoleColor,serverId,permissions:perms,createdAt:serverTimestamp()});
    document.getElementById('new-role-name').value='';
    showToast('Role created!','success');
    const snap=await getDocs(query(collection(db,'roles'),where('serverId','==',serverId)));
    window._serverRoles=snap.docs.map(d=>({id:d.id,...d.data()}));
    showRolesTab('list'); renderRolesList();
  };

  window.deleteRole=async function(roleId){
    await deleteDoc(doc(db,'roles',roleId));
    window._serverRoles=(window._serverRoles||[]).filter(r=>r.id!==roleId);
    renderRolesList(); showToast('Role deleted.','');
  };

  async function loadMembersForRoles(){
    const serverId=window._currentRolesServerId; if(!serverId) return;
    const roles=window._serverRoles||[];
    const membersSnap=await getDocs(query(collection(db,'serverMembers'),where('serverId','==',serverId)));
    const container=document.getElementById('members-roles-list'); container.innerHTML='';
    for (const m of membersSnap.docs) {
      const mData=m.data();
      if (mData.role==='owner') continue; // skip owner
      const uSnap=await getDoc(doc(db,'users',mData.userId));
      if (!uSnap.exists()||uSnap.data().deleted) continue;
      const u={...uSnap.data(),id:mData.userId};
      const name=u.displayName||u.username;
      const row=document.createElement('div'); row.className='member-row';
      const opts=`<option value="">No Role</option>`+roles.map(r=>`<option value="${r.id}" ${mData.assignedRoleId===r.id?'selected':''}>${esc(r.name)}</option>`).join('');
      row.innerHTML=`<div class="item-avatar" style="background:${color(u.username)}">${u.avatarUrl?`<img src="${u.avatarUrl}"/>`:name[0].toUpperCase()}</div><div class="member-info"><div class="member-name">${name}</div><div class="member-tag">@${u.username}</div></div><select class="member-role-select" onchange="assignRole('${serverId}','${mData.userId}',this.value)">${opts}</select>`;
      container.appendChild(row);
    }
    if (!container.children.length) container.innerHTML='<div style="color:var(--muted);font-size:0.86rem;text-align:center;padding:20px">No members to assign roles to.</div>';
  }

  window.assignRole=async function(serverId,userId,roleId){
    const docId=`${serverId}_${userId}`;
    if (roleId) await updateDoc(doc(db,'serverMembers',docId),{assignedRoleId:roleId});
    else await updateDoc(doc(db,'serverMembers',docId),{assignedRoleId:null});
    showToast('Role assigned!','success');
  };

  // ── CHANNEL PERMISSIONS ──
  window.openChannelPerms=async function(channelId,channelName,serverId){
    currentChannelForPerms={id:channelId,name:channelName,serverId};
    document.getElementById('ch-perm-name').textContent='#'+channelName;
    // Load roles for dropdowns
    const snap=await getDocs(query(collection(db,'roles'),where('serverId','==',serverId)));
    const roles=snap.docs.map(d=>({id:d.id,...d.data()}));
    const opts=`<option value="">Select a role</option>`+roles.map(r=>`<option value="${r.id}">${esc(r.name)}</option>`).join('');
    document.getElementById('ch-perm-role-select').innerHTML=opts;
    document.getElementById('ch-perm-send-role-select').innerHTML=opts;
    // Load existing perms
    const chSnap=await getDoc(doc(db,'channels',channelId));
    if (chSnap.exists()) {
      const perms=chSnap.data().permissions||{};
      document.getElementById('ch-perm-view-select').value=perms.view||'everyone';
      document.getElementById('ch-perm-send-select').value=perms.send||'everyone';
      if (perms.view==='role') { document.getElementById('ch-perm-role-group').style.display='flex'; document.getElementById('ch-perm-role-select').value=perms.viewRoleId||''; }
      if (perms.send==='role') { document.getElementById('ch-perm-send-role-group').style.display='flex'; document.getElementById('ch-perm-send-role-select').value=perms.sendRoleId||''; }
    }
    document.getElementById('ch-perm-view-select').onchange=function(){ document.getElementById('ch-perm-role-group').style.display=this.value==='role'?'flex':'none'; };
    document.getElementById('ch-perm-send-select').onchange=function(){ document.getElementById('ch-perm-send-role-group').style.display=this.value==='role'?'flex':'none'; };
    openModal('channelPermModal');
  };

  window.saveChannelPerms=async function(){
    if (!currentChannelForPerms) return;
    const view=document.getElementById('ch-perm-view-select').value;
    const send=document.getElementById('ch-perm-send-select').value;
    const viewRoleId=view==='role'?document.getElementById('ch-perm-role-select').value:'';
    const sendRoleId=send==='role'?document.getElementById('ch-perm-send-role-select').value:'';
    await updateDoc(doc(db,'channels',currentChannelForPerms.id),{permissions:{view,send,viewRoleId,sendRoleId}});
    closeModal('channelPermModal'); showToast('Permissions saved!','success');
    if (currentServer) await window.openServer(currentServer);
  };

  window.showServerSettings = function(server, channels) {
    // Build settings modal content
    document.getElementById('main-content').className = 'main-content';
    document.getElementById('main-header').innerHTML = `<button class="hamburger" onclick="toggleMobileSidebar()">☰</button><span>⚙️</span><h2>Server Settings</h2><button style="margin-left:auto" class="friend-btn" onclick="window.openServer(window.currentServer)">✕ Close</button>`;
    const mc = document.getElementById('main-content');
    mc.innerHTML = `
      <div style="max-width:540px;margin:0 auto;padding:28px 20px;display:flex;flex-direction:column;gap:18px">
        <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:1.1rem">${esc(server.name)}</div>

        <div style="background:var(--surface2);border:1px solid var(--border);border-radius:12px;padding:18px 20px;display:flex;flex-direction:column;gap:12px">
          <div style="font-size:0.7rem;font-weight:700;text-transform:uppercase;letter-spacing:0.08em;color:var(--muted)">Server Actions</div>
          <div style="display:flex;gap:10px;flex-wrap:wrap">
            <button class="modal-btn" style="flex:none;width:auto;padding:10px 18px;box-shadow:none" onclick="closeMobileSidebar();openInviteModal(window.currentServer)">🔗 Invite People</button>
            <button class="modal-btn secondary" style="flex:none;width:auto;padding:10px 18px" onclick="openModal('rolesModal');loadRolesModal(window.currentServer.id)">🎭 Manage Roles</button>
          </div>
        </div>

        <div style="background:rgba(255,95,87,0.06);border:1px solid rgba(255,95,87,0.2);border-radius:12px;padding:18px 20px">
          <div style="font-size:0.7rem;font-weight:700;text-transform:uppercase;letter-spacing:0.08em;color:var(--error);margin-bottom:10px">Danger Zone</div>
          <div style="font-size:0.85rem;color:var(--muted);margin-bottom:14px;line-height:1.6">Deleting this server is permanent and cannot be undone. All channels and messages will be erased for every member.</div>
          <button onclick="confirmDeleteServer('${server.id}','${esc(server.name)}')" style="padding:10px 20px;background:rgba(255,95,87,0.15);border:1px solid rgba(255,95,87,0.3);border-radius:8px;color:var(--error);font-family:'DM Sans',sans-serif;font-size:0.86rem;font-weight:700;cursor:pointer;transition:background 0.2s" onmouseover="this.style.background='rgba(255,95,87,0.25)'" onmouseout="this.style.background='rgba(255,95,87,0.15)'">🗑️ Delete Server</button>
        </div>
      </div>`;
  };

  window.confirmDeleteServer = function(serverId, serverName) {
    const confirmed = confirm(`Are you sure you want to permanently delete "${serverName}"? This cannot be undone.`);
    if (!confirmed) return;
    deleteServerPermanently(serverId, serverName);
  };

  async function deleteServerPermanently(serverId, serverName) {
    showToast('Deleting server...', '');
    try {
      // Delete all channels and their messages
      const chSnap = await getDocs(query(collection(db, 'channels'), where('serverId', '==', serverId)));
      for (const ch of chSnap.docs) {
        const msgSnap = await getDocs(collection(db, 'channels', ch.id, 'messages'));
        await Promise.all(msgSnap.docs.map(m => deleteDoc(m.ref)));
        await deleteDoc(ch.ref);
      }
      // Delete all serverMembers
      const memSnap = await getDocs(query(collection(db, 'serverMembers'), where('serverId', '==', serverId)));
      await Promise.all(memSnap.docs.map(m => deleteDoc(m.ref)));
      // Delete all roles
      const roleSnap = await getDocs(query(collection(db, 'roles'), where('serverId', '==', serverId)));
      await Promise.all(roleSnap.docs.map(r => deleteDoc(r.ref)));
      // Delete all invites
      const invSnap = await getDocs(query(collection(db, 'invites'), where('serverId', '==', serverId)));
      await Promise.all(invSnap.docs.map(i => deleteDoc(i.ref)));
      // Delete server doc
      await deleteDoc(doc(db, 'servers', serverId));
      // Return to home
      currentServer = null; window.currentServer = null;
      await loadServers();
      showView();
      showToast(`"${serverName}" has been deleted.`, 'success');
    } catch(e) {
      showToast('Failed to delete server: ' + e.message, 'error');
    }
  }

  // ══════════════════════════════════════════════════════
  // ── PROFILE — BANNER, EFFECTS, CROP, AVATAR ──
  // ══════════════════════════════════════════════════════

  // ── EFFECTS CATALOG ──
  const PROFILE_EFFECTS = [
    { id:'none',    label:'None',     bg:'linear-gradient(135deg,#23243a,#2d2e4a)' },
    { id:'sparkle', label:'✦ Sparkle', bg:'linear-gradient(135deg,#1a1a2e,#4a0080)' },
    { id:'aurora',  label:'Aurora',   bg:'linear-gradient(135deg,#003322,#001833)' },
    { id:'neon',    label:'Neon',     bg:'linear-gradient(135deg,#001a1a,#002a22)' },
    { id:'holo',    label:'Holo',     bg:'linear-gradient(135deg,#1a001a,#001a2a)' },
    { id:'stars',   label:'★ Stars',  bg:'linear-gradient(135deg,#050510,#0a0a28)' },
    { id:'fire',    label:'🔥 Fire',   bg:'linear-gradient(135deg,#1a0500,#2a0a00)' },
    { id:'ice',     label:'❄ Ice',    bg:'linear-gradient(135deg,#001020,#002040)' },
    { id:'glitch',  label:'Glitch',   bg:'linear-gradient(135deg,#0a000a,#001a10)' },
  ];

  let pendingEffect = null; // selected effect id (null = no change)

  function buildEffectGrid() {
    const grid = document.getElementById('effect-grid');
    if (!grid) return;
    grid.innerHTML = '';
    const current = currentProfile.effect || 'none';
    PROFILE_EFFECTS.forEach(fx => {
      const card = document.createElement('div');
      card.className = 'effect-card' + (fx.id === current ? ' selected' : '');
      card.dataset.fxId = fx.id;
      // Preview: mini banner with the effect applied
      card.innerHTML = `
        <div class="effect-card-preview pp-banner fx-${fx.id}" style="background:${fx.bg};position:relative;width:100%;height:100%"></div>
        <div class="effect-card-label">${fx.label}</div>`;
      card.addEventListener('click', () => {
        grid.querySelectorAll('.effect-card').forEach(c => c.classList.remove('selected'));
        card.classList.add('selected');
        pendingEffect = fx.id;
      });
      grid.appendChild(card);
    });
  }

  // ── BANNER STATE ──
  let pendingBannerFile = null;     // File object picked by user
  let pendingBannerDataUrl = null;  // base64 of original file for crop preview
  let pendingBannerRemove = false;
  // Crop state
  let cropScale = 1, cropOffX = 0, cropOffY = 0;
  let cropImgEl = null, cropStageW = 0, cropStageH = 0;
  let cropNatW = 0, cropNatH = 0;
  // Stored crop result
  let cropResult = null; // { objectPositionX%, objectPositionY% } — used for object-position on display

  window.handleBannerUpload = function(event) {
    const file = event.target.files[0];
    if (!file) return;
    if (file.size > 8 * 1024 * 1024) { showToast('Banner must be under 8MB', 'error'); return; }
    pendingBannerFile = file;
    pendingBannerRemove = false;
    cropResult = null;
    const reader = new FileReader();
    reader.onload = e => {
      pendingBannerDataUrl = e.target.result;
      updateBannerPreview();
      openBannerCrop();
    };
    reader.readAsDataURL(file);
    // reset input so same file can be re-picked
    event.target.value = '';
  };

  function updateBannerPreview() {
    const preview = document.getElementById('profile-banner-preview');
    if (!preview) return;
    // Remove old media
    preview.querySelectorAll('img,video').forEach(el => el.remove());
    if (pendingBannerRemove || (!pendingBannerDataUrl && !currentProfile.bannerUrl)) {
      preview.style.background = `linear-gradient(135deg,${color(currentProfile.username)},${color(currentProfile.username+'2')})`;
      document.getElementById('banner-crop-btn').style.display = 'none';
      document.getElementById('banner-remove-btn').style.display = 'none';
      return;
    }
    const src = pendingBannerDataUrl || currentProfile.bannerUrl;
    const isGif = src.includes('.gif') || src.startsWith('data:image/gif');
    const el = isGif ? document.createElement('video') : document.createElement('img');
    if (isGif) {
      el.src = src; el.autoplay = true; el.loop = true; el.muted = true; el.playsInline = true;
    } else {
      el.src = src;
    }
    // Apply stored crop position
    if (cropResult) {
      el.style.objectPosition = `${cropResult.x}% ${cropResult.y}%`;
    } else if (currentProfile.bannerPos) {
      el.style.objectPosition = currentProfile.bannerPos;
    }
    preview.style.background = 'none';
    preview.insertBefore(el, preview.firstChild);
    document.getElementById('banner-crop-btn').style.display = pendingBannerDataUrl ? '' : 'none';
    document.getElementById('banner-remove-btn').style.display = '';
  }

  window.removeBanner = function() {
    pendingBannerFile = null;
    pendingBannerDataUrl = null;
    pendingBannerRemove = true;
    cropResult = null;
    updateBannerPreview();
  };

  // ── CROP MODAL ──
  window.openBannerCrop = function() {
    if (!pendingBannerDataUrl) return;
    const stage = document.getElementById('crop-stage');
    stage.innerHTML = '';
    cropScale = 1; cropOffX = 0; cropOffY = 0;
    document.getElementById('crop-zoom').value = 100;
    document.getElementById('crop-zoom-label').textContent = '1×';

    const isGif = pendingBannerDataUrl.startsWith('data:image/gif');
    if (isGif) {
      cropImgEl = document.createElement('video');
      cropImgEl.src = pendingBannerDataUrl;
      cropImgEl.autoplay = true; cropImgEl.loop = true; cropImgEl.muted = true; cropImgEl.playsInline = true;
      cropImgEl.onloadedmetadata = () => { cropNatW = cropImgEl.videoWidth; cropNatH = cropImgEl.videoHeight; fitCropToStage(); };
    } else {
      cropImgEl = document.createElement('img');
      cropImgEl.src = pendingBannerDataUrl;
      cropImgEl.onload = () => { cropNatW = cropImgEl.naturalWidth; cropNatH = cropImgEl.naturalHeight; fitCropToStage(); };
    }
    cropImgEl.style.position = 'absolute';
    cropImgEl.style.transformOrigin = '0 0';
    cropImgEl.draggable = false;
    stage.appendChild(cropImgEl);
    stage.appendChild(Object.assign(document.createElement('div'), { className: 'crop-overlay' }));

    // Stage dimensions — read after render
    requestAnimationFrame(() => {
      cropStageW = stage.offsetWidth;
      cropStageH = stage.offsetHeight;
    });

    setupCropDrag(stage);
    closeModal('profileModal');
    openModal('bannerCropModal');
  };

  function fitCropToStage() {
    if (!cropNatW || !cropNatH) return;
    cropStageW = document.getElementById('crop-stage').offsetWidth;
    cropStageH = document.getElementById('crop-stage').offsetHeight;
    // Fit image so it covers the stage at scale=1
    const scaleToFit = Math.max(cropStageW / cropNatW, cropStageH / cropNatH);
    // Store base scale so zoom=100 always covers stage
    cropImgEl._baseScale = scaleToFit;
    cropScale = 1;
    cropOffX = (cropStageW - cropNatW * scaleToFit) / 2;
    cropOffY = (cropStageH - cropNatH * scaleToFit) / 2;
    applyCropTransform();
  }

  function applyCropTransform() {
    if (!cropImgEl || !cropImgEl._baseScale) return;
    const s = cropImgEl._baseScale * cropScale;
    cropImgEl.style.transform = `translate(${cropOffX}px, ${cropOffY}px) scale(${s})`;
    cropImgEl.style.width = cropNatW + 'px';
    cropImgEl.style.height = cropNatH + 'px';
    clampCropOffset();
  }

  function clampCropOffset() {
    if (!cropImgEl || !cropImgEl._baseScale) return;
    const s = cropImgEl._baseScale * cropScale;
    const imgW = cropNatW * s, imgH = cropNatH * s;
    cropOffX = Math.min(0, Math.max(cropStageW - imgW, cropOffX));
    cropOffY = Math.min(0, Math.max(cropStageH - imgH, cropOffY));
    const s2 = cropImgEl._baseScale * cropScale;
    cropImgEl.style.transform = `translate(${cropOffX}px, ${cropOffY}px) scale(${s2})`;
  }

  window.updateCropZoom = function(val) {
    cropScale = val / 100;
    document.getElementById('crop-zoom-label').textContent = cropScale.toFixed(1) + '×';
    applyCropTransform();
    clampCropOffset();
  };

  function setupCropDrag(stage) {
    let dragging = false, lastX = 0, lastY = 0;
    let lastPinchDist = null;
    stage.addEventListener('mousedown', e => { dragging = true; lastX = e.clientX; lastY = e.clientY; e.preventDefault(); });
    window.addEventListener('mousemove', e => {
      if (!dragging) return;
      cropOffX += e.clientX - lastX; cropOffY += e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      clampCropOffset();
    });
    window.addEventListener('mouseup', () => { dragging = false; });
    // Touch drag
    stage.addEventListener('touchstart', e => {
      if (e.touches.length === 1) { dragging = true; lastX = e.touches[0].clientX; lastY = e.touches[0].clientY; }
      else if (e.touches.length === 2) { lastPinchDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); }
      e.preventDefault();
    }, { passive: false });
    stage.addEventListener('touchmove', e => {
      if (e.touches.length === 1 && dragging) {
        cropOffX += e.touches[0].clientX - lastX; cropOffY += e.touches[0].clientY - lastY;
        lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
        clampCropOffset();
      } else if (e.touches.length === 2 && lastPinchDist !== null) {
        const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
        const delta = dist / lastPinchDist;
        cropScale = Math.min(4, Math.max(1, cropScale * delta));
        lastPinchDist = dist;
        const slider = document.getElementById('crop-zoom');
        if (slider) { slider.value = cropScale * 100; document.getElementById('crop-zoom-label').textContent = cropScale.toFixed(1) + '×'; }
        applyCropTransform();
      }
      e.preventDefault();
    }, { passive: false });
    stage.addEventListener('touchend', e => { if (e.touches.length < 2) lastPinchDist = null; if (e.touches.length === 0) dragging = false; });
    // Mouse wheel zoom
    stage.addEventListener('wheel', e => {
      cropScale = Math.min(4, Math.max(1, cropScale - e.deltaY * 0.005));
      const slider = document.getElementById('crop-zoom');
      if (slider) { slider.value = cropScale * 100; document.getElementById('crop-zoom-label').textContent = cropScale.toFixed(1) + '×'; }
      applyCropTransform();
      e.preventDefault();
    }, { passive: false });
  }

  window.applyCrop = function() {
    if (!cropImgEl || !cropImgEl._baseScale) { closeModal('bannerCropModal'); openModal('profileModal'); return; }
    // Convert current pan/zoom into object-position percentages
    const s = cropImgEl._baseScale * cropScale;
    const imgW = cropNatW * s, imgH = cropNatH * s;
    // object-position: the percentage of the image the crop left/top edge falls on
    const xPct = imgW > cropStageW ? (Math.abs(cropOffX) / (imgW - cropStageW)) * 100 : 50;
    const yPct = imgH > cropStageH ? (Math.abs(cropOffY) / (imgH - cropStageH)) * 100 : 50;
    cropResult = { x: Math.round(xPct), y: Math.round(yPct) };
    closeModal('bannerCropModal');
    openModal('profileModal');
    updateBannerPreview();
  };

  window.openProfileModal = function() {
    document.getElementById('display-name-input').value = currentProfile.displayName || '';
    document.getElementById('bio-input').value = currentProfile.bio || '';
    document.getElementById('username-readonly').value = '@' + currentProfile.username;
    selectedStatus = currentProfile.status || 'online';
    document.querySelectorAll('.status-option').forEach(o => o.classList.toggle('selected', o.dataset.status === selectedStatus));
    const preview = document.getElementById('profile-avatar-preview');
    const name = currentProfile.displayName || currentProfile.username;
    if (currentProfile.avatarUrl) { preview.innerHTML = `<img src="${currentProfile.avatarUrl}"/>`; preview.style.background = ''; }
    else { preview.innerHTML = name[0].toUpperCase(); preview.style.background = color(currentProfile.username); }
    // Reset pending state
    pendingAvatarDataUrl = null; pendingAvatarFile = null;
    pendingBannerFile = null; pendingBannerDataUrl = null; pendingBannerRemove = false; cropResult = null;
    pendingEffect = null;
    updateBannerPreview();
    buildEffectGrid();
    openModal('profileModal');
  };

  window.selectStatus = card => { document.querySelectorAll('.status-option').forEach(c => c.classList.remove('selected')); card.classList.add('selected'); selectedStatus = card.dataset.status; };

  let pendingAvatarFile = null;
  window.handleAvatarUpload = function(event) {
    const file = event.target.files[0]; if (!file) return;
    if (file.size > 8*1024*1024) { showToast('Image must be under 8MB', 'error'); return; }
    pendingAvatarFile = file;
    const reader = new FileReader();
    reader.onload = e => { pendingAvatarDataUrl = e.target.result; const p = document.getElementById('profile-avatar-preview'); p.innerHTML = `<img src="${pendingAvatarDataUrl}"/>`; p.style.background = ''; };
    reader.readAsDataURL(file);
  };
  window.removeAvatar = function() {
    pendingAvatarDataUrl = 'remove';
    const p = document.getElementById('profile-avatar-preview');
    const n = document.getElementById('display-name-input').value || currentProfile.username;
    p.innerHTML = n[0].toUpperCase(); p.style.background = color(currentProfile.username);
  };

  window.saveProfile = async function() {
    const displayName = document.getElementById('display-name-input').value.trim();
    const bio = document.getElementById('bio-input').value.trim();

    // ── Avatar upload ──
    let avatarUrl = currentProfile.avatarUrl || '';
    if (pendingAvatarDataUrl === 'remove') { avatarUrl = ''; }
    else if (pendingAvatarFile) {
      showToast('Uploading photo...', '');
      try {
        const fd = new FormData();
        fd.append('file', pendingAvatarFile);
        fd.append('upload_preset', CLOUDINARY_PRESET);
        fd.append('public_id', `avatars/${currentUser.uid}_${Date.now()}`);
        const res = await fetch(`https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD}/image/upload`, { method: 'POST', body: fd });
        const data = await res.json();
        if (data.secure_url) avatarUrl = data.secure_url;
        else { showToast('Avatar upload failed: ' + (data.error?.message || 'unknown'), 'error'); return; }
      } catch(e) { showToast('Avatar upload failed: ' + e.message, 'error'); return; }
    }

    // ── Banner upload ──
    let bannerUrl = currentProfile.bannerUrl || '';
    let bannerPos = currentProfile.bannerPos || '50% 50%';
    if (pendingBannerRemove) { bannerUrl = ''; bannerPos = '50% 50%'; }
    else if (pendingBannerFile) {
      showToast('Uploading banner...', '');
      try {
        const fd = new FormData();
        fd.append('file', pendingBannerFile);
        fd.append('upload_preset', CLOUDINARY_PRESET);
        fd.append('public_id', `banners/${currentUser.uid}_${Date.now()}`);
        const res = await fetch(`https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD}/image/upload`, { method: 'POST', body: fd });
        const data = await res.json();
        if (data.secure_url) bannerUrl = data.secure_url;
        else { showToast('Banner upload failed: ' + (data.error?.message || 'unknown'), 'error'); return; }
      } catch(e) { showToast('Banner upload failed: ' + e.message, 'error'); return; }
    }
    if (cropResult) bannerPos = `${cropResult.x}% ${cropResult.y}%`;

    // ── Effect ──
    const effect = pendingEffect !== null ? pendingEffect : (currentProfile.effect || 'none');

    const manualStatus = selectedStatus !== 'online' ? selectedStatus : null;
    await updateDoc(doc(db, 'users', currentUser.uid), { displayName, bio, avatarUrl, bannerUrl, bannerPos, effect, status: selectedStatus, manualStatus });
    currentProfile = { ...currentProfile, displayName, bio, avatarUrl, bannerUrl, bannerPos, effect, status: selectedStatus, manualStatus };
    userCache[currentUser.uid] = { ...currentProfile, id: currentUser.uid };
    pendingAvatarDataUrl = null; pendingAvatarFile = null;
    pendingBannerFile = null; pendingBannerDataUrl = null; pendingBannerRemove = false; cropResult = null; pendingEffect = null;
    updateSidebarUser();
    closeModal('profileModal');
    showToast('Profile saved! ✨', 'success');
  };

  // ── DELETE ACCOUNT ──
  window.confirmDeleteAccount=function(){ closeModal('profileModal'); document.getElementById('delete-confirm-input').value=''; openModal('deleteAccountModal'); };
  window.deleteAccount=async function(){
    if (document.getElementById('delete-confirm-input').value.trim()!=='DELETE'){showToast('Type DELETE to confirm','error');return;}
    try { await updateDoc(doc(db,'users',currentUser.uid),{deleted:true,deletedAt:serverTimestamp(),displayName:'Deleted User',avatarUrl:'',bio:'',status:'offline',email:''}); const user=auth.currentUser; await signOut(auth); try{await deleteUser(user);}catch(e){} window.location.href='index.html'; } catch(e){showToast('Please sign out and back in first, then try again.','error');}
  };

  // ══════════════════════════════════════
  // ── CALLS & WEBRTC ──
  // ══════════════════════════════════════
  let activeCallId = null;
  let callUnsubscribe = null;
  let localStream = null;
  let screenStream = null;       // local screen capture stream
  let isSharingScreen = false;
  let screenShareSenderId = null; // uid of whoever is currently sharing (null = nobody)
  let peerConnections = {}; // peerId -> RTCPeerConnection
  let currentCallParticipants = []; // array of {uid, name, avatarUrl, username}

  const ICE_SERVERS = { iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },
    { urls: 'stun:stun3.l.google.com:19302' },
    { urls: 'stun:stun4.l.google.com:19302' },
    // Open TURN relay — handles symmetric NATs (the main reason P2P fails)
    { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
    { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
    { urls: 'turn:openrelay.metered.ca:443?transport=tcp', username: 'openrelayproject', credential: 'openrelayproject' },
  ]};

  // ── SIGNALING HELPERS ──
  // Uses a single 'rtcSignaling' collection. Doc ID = sorted pair of UIDs joined by '_'
  // For voice channels: ID = 'vc_' + channelId + '_' + uid1 + '_' + uid2 (per-pair)
  // This way security rules only need: allow read,write if request.auth.uid in resource.data.participants

  function signalingDocId(uidA, uidB, voiceChannelId) {
    const pair = [uidA, uidB].sort().join('__');
    return voiceChannelId ? 'vc_' + voiceChannelId + '__' + pair : pair;
  }

  function signalingRef(callId, peerId) {
    // callId is the Firestore calls doc ID for DM/group calls
    // For voice channels callId = 'voice_' + channelId
    const vcMatch = callId.match(/^voice_(.+)$/);
    const docId = vcMatch
      ? signalingDocId(currentUser.uid, peerId, vcMatch[1])
      : signalingDocId(currentUser.uid, peerId, null) + '__' + callId;
    return doc(db, 'rtcSignaling', docId);
  }

  async function ensureSignalingDoc(callId, peerId) {
    const ref = signalingRef(callId, peerId);
    try {
      await setDoc(ref, {
        participants: [currentUser.uid, peerId],
        callId: callId,
        created: serverTimestamp()
      }, { merge: true });
    } catch(e) { console.warn('ensureSignalingDoc error', e); }
    return ref;
  }

  async function signalingUpdate(callId, peerId, data) {
    const ref = signalingRef(callId, peerId);
    try {
      await updateDoc(ref, data);
    } catch(e) {
      if (e.code === 'not-found') {
        await setDoc(ref, { participants: [currentUser.uid, peerId], ...data }, { merge: true });
      } else { console.warn('signalingUpdate error', e); }
    }
  }

  function setAvEl(el, profile) {
    if (!el) return;
    const name = profile?.displayName || profile?.username || '?';
    el.style.background = color(profile?.username || 'x');
    el.innerHTML = profile?.avatarUrl
      ? `<img src="${profile.avatarUrl}" style="width:100%;height:100%;object-fit:cover"/>`
      : (name[0] || '?').toUpperCase();
  }

  function showCallPip(sub, participants) {
    const pip = document.getElementById('call-pip');
    const avatarsEl = document.getElementById('call-pip-avatars');
    const subEl = document.getElementById('call-pip-sub');
    avatarsEl.innerHTML = '';
    participants.slice(0, 4).forEach(p => {
      const av = document.createElement('div'); av.className = 'call-pip-av';
      av.style.background = color(p.username || 'x');
      av.innerHTML = p.avatarUrl ? `<img src="${p.avatarUrl}" style="width:100%;height:100%;object-fit:cover"/>` : (p.name?.[0] || '?').toUpperCase();
      avatarsEl.appendChild(av);
    });
    subEl.textContent = sub;
    pip.classList.add('visible');
    pip.onclick = () => openModal('callModal');
  }

  function hideCallPip() {
    document.getElementById('call-pip').classList.remove('visible');
  }

  async function getLocalAudio() {
    try {
      if (!localStream) localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
      return localStream;
    } catch(e) {
      showToast('Microphone access denied — audio unavailable', 'error');
      return null;
    }
  }

  // ── ICE key helper: always sorted so both sides use same field ──
  function iceKey(a, b) { return 'ice_' + [a,b].sort().join('_x_'); }
  // Track which ICE candidates we've already applied per peer
  const appliedIce = {}; // peerId -> Set of JSON strings

  function createPeerConnection(peerId, callId, stream) {
    if (peerConnections[peerId]) { try { peerConnections[peerId].close(); } catch(e){} }
    const pc = new RTCPeerConnection(ICE_SERVERS);
    peerConnections[peerId] = pc;
    appliedIce[peerId] = new Set();

    // Add local audio tracks immediately — stream is guaranteed here
    stream.getAudioTracks().forEach(t => pc.addTrack(t, stream));

    // Remote media handler
    pc.ontrack = e => {
      const track = e.track;
      if (track.kind === 'audio') {
        let audio = document.getElementById('remote-audio-' + peerId);
        if (!audio) {
          audio = document.createElement('audio');
          audio.id = 'remote-audio-' + peerId;
          audio.autoplay = true;
          audio.style.display = 'none';
          document.body.appendChild(audio);
        }
        audio.srcObject = new MediaStream([track]);
      } else if (track.kind === 'video') {
        receiveRemoteScreenShare(peerId, e.streams[0], track);
        track.onended = () => clearRemoteScreenShare(peerId);
      }
    };

    // ICE → store in signaling doc as arrayUnion
    pc.onicecandidate = async e => {
      if (!e.candidate) return;
      const key = 'ice_from_' + currentUser.uid;
      try {
        await signalingUpdate(callId, peerId, { [key]: arrayUnion(JSON.stringify(e.candidate.toJSON())) });
      } catch(err) { console.warn('ICE write error', err); }
    };

    pc.onconnectionstatechange = () => {
      console.log('PeerConnection state:', peerId, pc.connectionState);
      if (['disconnected','failed','closed'].includes(pc.connectionState)) {
        try { pc.close(); } catch(e) {}
        delete peerConnections[peerId];
        delete appliedIce[peerId];
        const audioEl = document.getElementById('remote-audio-' + peerId);
        if (audioEl) audioEl.remove();
      }
    };

    return pc;
  }

  // Apply ICE candidates from snapshot data that we haven't seen yet
  async function applyIceCandidates(pc, peerId, sigData) {
    const key = 'ice_from_' + peerId;
    const candidates = sigData[key] || [];
    if (!appliedIce[peerId]) appliedIce[peerId] = new Set();
    for (const raw of candidates) {
      if (appliedIce[peerId].has(raw)) continue;
      appliedIce[peerId].add(raw);
      try {
        const candidate = JSON.parse(raw);
        if (pc.remoteDescription && pc.signalingState !== 'closed') {
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
        }
      } catch(e) { console.warn('ICE apply error', e); }
    }
  }

  async function startWebRTCWith(peerId, callId) {
    const stream = await getLocalAudio();
    if (!stream) return;
    // Pre-create signaling doc so both sides can write to it
    await ensureSignalingDoc(callId, peerId);
    const pc = createPeerConnection(peerId, callId, stream);

    // Create offer
    const offer = await pc.createOffer({ offerToReceiveAudio: true });
    await pc.setLocalDescription(offer);
    await signalingUpdate(callId, peerId, { offer: { sdp: offer.sdp, type: offer.type, from: currentUser.uid } });

    // Listen on signaling doc for answer + ICE
    const sRef = signalingRef(callId, peerId);
    const unsub = onSnapshot(sRef, async snap => {
      if (!snap.exists()) return;
      const d = snap.data();
      if (d.answer && pc.signalingState === 'have-local-offer') {
        try {
          await pc.setRemoteDescription(new RTCSessionDescription({ type: d.answer.type, sdp: d.answer.sdp }));
        } catch(e) { console.warn('setRemoteDesc error', e); }
      }
      if (pc.remoteDescription) await applyIceCandidates(pc, peerId, d);
    });
    pc._unsub = unsub;
  }

  async function answerWebRTCFrom(peerId, callId) {
    const stream = await getLocalAudio();
    if (!stream) return;

    // Poll for offer on the signaling doc (may not be there yet)
    const sRef = signalingRef(callId, peerId);
    let sigData = null;
    for (let i = 0; i < 15; i++) {
      const snap = await getDoc(sRef);
      if (snap.exists() && snap.data().offer) { sigData = snap.data(); break; }
      await new Promise(r => setTimeout(r, 700));
    }
    if (!sigData?.offer) { console.warn('No offer found from', peerId, 'on', sRef.path); return; }

    const pc = createPeerConnection(peerId, callId, stream);
    await pc.setRemoteDescription(new RTCSessionDescription({ type: sigData.offer.type, sdp: sigData.offer.sdp }));

    // Apply any ICE candidates that arrived before we set remote desc
    await applyIceCandidates(pc, peerId, sigData);

    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    await signalingUpdate(callId, peerId, { answer: { sdp: answer.sdp, type: answer.type, from: currentUser.uid } });

    // Listen for more ICE + renegotiation
    const unsub = onSnapshot(sRef, async snap => {
      if (!snap.exists()) return;
      const d = snap.data();
      if (pc.remoteDescription) await applyIceCandidates(pc, peerId, d);
      // Renegotiation: new offer while connected
      if (d.offer?.renegotiate && d.offer.from !== currentUser.uid && pc.signalingState === 'stable') {
        try {
          await pc.setRemoteDescription(new RTCSessionDescription({ type: d.offer.type, sdp: d.offer.sdp }));
          const reAnswer = await pc.createAnswer();
          await pc.setLocalDescription(reAnswer);
          await signalingUpdate(callId, peerId, { answer: { sdp: reAnswer.sdp, type: reAnswer.type, from: currentUser.uid } });
        } catch(e) { console.warn('renegotiate answer error', e); }
      }
    });
    pc._unsub = unsub;
  }

  function renderCallModal(participants, status) {
    // Hide screen share button if not supported by this browser
    const shareBtn = document.getElementById('screenshare-btn');
    if (shareBtn) shareBtn.style.display = navigator.mediaDevices?.getDisplayMedia ? '' : 'none';
    // Use persistent DOM elements — just update content
    const grid = document.getElementById('call-participants-row');
    const statusEl = document.getElementById('call-status');
    if (grid) {
      grid.innerHTML = '';
      participants.forEach(p => {
        const av = document.createElement('div'); av.className = 'call-part-av';
        av.id = 'call-av-' + p.uid;
        av.style.background = color(p.username || 'x');
        av.innerHTML = `<div class="speaking-ring"></div>` + (p.avatarUrl
          ? `<img src="${p.avatarUrl}" style="width:100%;height:100%;object-fit:cover;border-radius:50%"/>`
          : (p.name?.[0] || '?').toUpperCase());
        av.title = p.name || '';
        grid.appendChild(av);
      });
    }
    if (statusEl) statusEl.textContent = status;
    // Update mute button state
    const muteBtn = document.getElementById('mute-btn');
    if (muteBtn) muteBtn.textContent = isMuted ? '🔇 Unmute' : '🎤 Mute';
  }

  let isMuted = false;
  window.toggleMute = function() {
    isMuted = !isMuted;
    // Mute/unmute the local stream tracks directly
    if (localStream) localStream.getAudioTracks().forEach(t => { t.enabled = !isMuted; });
    // Also reach into every peer connection's senders — belt AND suspenders
    Object.values(peerConnections).forEach(pc => {
      pc.getSenders().forEach(sender => {
        if (sender.track && sender.track.kind === 'audio') {
          sender.track.enabled = !isMuted;
        }
      });
    });
    const btn = document.getElementById('mute-btn');
    if (btn) {
      btn.textContent = isMuted ? '🔇 Unmute' : '🎤 Mute';
      btn.classList.toggle('active', isMuted);
    }
  };

  function cleanupCall() {
    Object.values(peerConnections).forEach(pc => {
      try { if (pc._unsub) pc._unsub(); pc.close(); } catch(e) {}
    });
    peerConnections = {};
    Object.keys(appliedIce).forEach(k => delete appliedIce[k]);
    if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
    if (screenStream) { screenStream.getTracks().forEach(t => t.stop()); screenStream = null; }
    isSharingScreen = false;
    isMuted = false;
    document.querySelectorAll('[id^="remote-audio-"]').forEach(el => el.remove());
    if (callUnsubscribe) { callUnsubscribe(); callUnsubscribe = null; }
    clearScreenShareView();
    activeCallId = null;
    currentCallParticipants = [];
    hideCallPip();
    // Reset buttons
    const shareBtn = document.getElementById('screenshare-btn');
    if (shareBtn) { shareBtn.textContent = '🖥️ Share Screen'; shareBtn.classList.remove('active'); }
    const muteBtn = document.getElementById('mute-btn');
    if (muteBtn) muteBtn.textContent = '🎤 Mute';
  }

  // ══════════════════════════════════════
  // ── SCREEN SHARE ──
  // ══════════════════════════════════════

  window.toggleScreenShare = async function() {
    if (isSharingScreen) {
      await stopScreenShare();
    } else {
      await startScreenShare();
    }
  };

  async function startScreenShare() {
    // getDisplayMedia is desktop-only — not supported on Android/iOS browsers
    if (!navigator.mediaDevices?.getDisplayMedia) {
      showToast('Screen sharing is only available on desktop browsers', 'error');
      return;
    }
    try {
      screenStream = await navigator.mediaDevices.getDisplayMedia({
        video: { frameRate: { ideal: 30, max: 60 }, width: { ideal: 1920 }, height: { ideal: 1080 } },
        audio: true  // system audio if browser supports it
      });
    } catch(e) {
      if (e.name === 'NotAllowedError') showToast('Screen share cancelled', '');
      else showToast('Could not share screen: ' + e.message, 'error');
      return;
    }

    isSharingScreen = true;
    const shareBtn = document.getElementById('screenshare-btn');
    if (shareBtn) { shareBtn.textContent = '🛑 Stop Sharing'; shareBtn.classList.add('active'); }

    // Show self-preview pip while sharing
    const pipVid = document.getElementById('screenshare-self-pip');
    if (pipVid) { pipVid.srcObject = screenStream; document.getElementById('screenshare-pip').style.display = 'block'; }

    // Show the screen share view with self's own stream
    showScreenShareView(currentUser.uid, screenStream,
      currentProfile.displayName || currentProfile.username);

    // Push screen video track into all existing peer connections
    const videoTrack = screenStream.getVideoTracks()[0];
    for (const [peerId, pc] of Object.entries(peerConnections)) {
      const senders = pc.getSenders();
      const videoSender = senders.find(s => s.track && s.track.kind === 'video');
      if (videoSender) {
        await videoSender.replaceTrack(videoTrack);
      } else {
        pc.addTrack(videoTrack, screenStream);
        // Re-negotiate
        await renegotiate(peerId, pc);
      }
    }

    // When user stops via browser's built-in stop button
    videoTrack.onended = () => stopScreenShare();
  }

  async function stopScreenShare() {
    isSharingScreen = false;
    if (screenStream) { screenStream.getTracks().forEach(t => t.stop()); screenStream = null; }

    const shareBtn = document.getElementById('screenshare-btn');
    if (shareBtn) { shareBtn.textContent = '🖥️ Share Screen'; shareBtn.classList.remove('active'); }

    // Remove video track from all peers
    for (const [peerId, pc] of Object.entries(peerConnections)) {
      const senders = pc.getSenders();
      const videoSender = senders.find(s => s.track && s.track.kind === 'video');
      if (videoSender) { pc.removeTrack(videoSender); await renegotiate(peerId, pc); }
    }

    // Clear self pip
    const pip = document.getElementById('screenshare-pip');
    if (pip) { pip.style.display = 'none'; const v = document.getElementById('screenshare-self-pip'); if(v) v.srcObject = null; }

    // Hide share view (was showing own share)
    if (screenShareSenderId === currentUser.uid) clearScreenShareView();
  }

  async function renegotiate(peerId, pc) {
    try {
      const cid = activeCallId || '';
      if (!cid) return;
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await signalingUpdate(cid, peerId, { offer: { sdp: offer.sdp, type: offer.type, from: currentUser.uid, renegotiate: true } });
    } catch(e) { console.warn('renegotiate error:', e); }
  }

  function showScreenShareView(senderUid, stream, senderName) {
    screenShareSenderId = senderUid;
    const view = document.getElementById('screenshare-view');
    const vid = document.getElementById('screenshare-video');
    const label = document.getElementById('screenshare-label');
    const modal = document.getElementById('callModal');
    if (!view || !vid) return;
    vid.srcObject = stream;
    vid.play().catch(()=>{});
    if (label) label.textContent = senderUid === currentUser.uid
      ? '📡 You are sharing your screen'
      : `📡 ${esc(senderName || 'Someone')} is sharing their screen`;
    view.classList.add('visible');
    // Widen modal
    if (modal) modal.querySelector('.modal').style.maxWidth = 'min(92vw, 820px)';
    // Hide avatars to give room
    const row = document.getElementById('call-participants-row');
    if (row) row.style.display = 'none';
  }

  function clearScreenShareView() {
    screenShareSenderId = null;
    const view = document.getElementById('screenshare-view');
    const vid = document.getElementById('screenshare-video');
    const modal = document.getElementById('callModal');
    if (view) view.classList.remove('visible');
    if (vid) { vid.srcObject = null; }
    if (modal) modal.querySelector('.modal').style.maxWidth = '340px';
    // Restore avatars
    const row = document.getElementById('call-participants-row');
    if (row) row.style.display = '';
  }

  function receiveRemoteScreenShare(peerId, stream, track) {
    const participant = currentCallParticipants.find(p => p.uid === peerId);
    showScreenShareView(peerId, stream, participant?.name || 'Someone');
  }

  function clearRemoteScreenShare(peerId) {
    if (screenShareSenderId === peerId) clearScreenShareView();
  }

  // Listen for share signals from other call participants
  function listenForScreenShares(callId) {
    // Screen share state is stored as 'screenShare' field on the call/voiceSignaling doc
    // We listen to all rtcSignaling docs for this call to detect shares from any peer
    // Simple approach: each peer's signaling doc has a 'sharing' field
    // The video track itself arrives via ontrack — this just updates the label
    // Nothing needed here beyond what ontrack already handles for video
    // Store callId so screen share signal writes know where to go
    window._activeScreenShareCallId = callId;
  }

    window.startCall = async function(friend) {
    if (!friend || friend.deleted) return;
    // Check status
    const fSnap = await getDoc(doc(db, 'users', friend.id));
    const fData = fSnap.exists() ? fSnap.data() : {};
    const fStatus = fData.status || 'offline';
    if (fStatus === 'dnd' || fStatus === 'invisible' || fStatus === 'offline') {
      showToast(fStatus === 'dnd' ? `${friend.displayName || friend.username} is on Do Not Disturb` : `${friend.displayName || friend.username} is offline`, 'error');
      return;
    }
    // Get audio permission early
    await getLocalAudio();

    const me = { uid: currentUser.uid, name: currentProfile.displayName || currentProfile.username, username: currentProfile.username, avatarUrl: currentProfile.avatarUrl || '' };
    const them = { uid: friend.id, name: friend.displayName || friend.username, username: friend.username, avatarUrl: friend.avatarUrl || '' };
    currentCallParticipants = [me, them];

    const callRef = await addDoc(collection(db, 'calls'), {
      callerId: currentUser.uid, callerName: me.name, callerUsername: me.username, callerAvatar: me.avatarUrl,
      recipientId: friend.id, recipientName: them.name, recipientUsername: them.username, recipientAvatar: them.avatarUrl,
      participants: [me, them], status: 'ringing', type: 'dm', createdAt: serverTimestamp(),
    });
    activeCallId = callRef.id;

    renderCallModal(currentCallParticipants, 'Ringing...');
    showCallPip('Ringing...', currentCallParticipants);
    openModal('callModal');

    callUnsubscribe = onSnapshot(doc(db, 'calls', callRef.id), async snap => {
      if (!snap.exists()) { cleanupCall(); closeModal('callModal'); return; }
      const d = snap.data();
      const statusEl = document.getElementById('call-status');
      if (d.status === 'accepted') {
        if (statusEl) statusEl.textContent = 'Connected ✓';
        showCallPip('In call · ' + them.name, currentCallParticipants);
        await startWebRTCWith(friend.id, callRef.id);
        listenForScreenShares(callRef.id);
      } else if (d.status === 'declined') {
        cleanupCall(); closeModal('callModal');
        showToast(`${them.name} declined the call`, 'error');
      } else if (d.status === 'ended') {
        cleanupCall(); closeModal('callModal');
      }
    });

    setTimeout(async () => {
      if (!activeCallId || activeCallId !== callRef.id) return;
      try {
        const s = await getDoc(doc(db, 'calls', activeCallId));
        if (s.exists() && s.data().status === 'ringing') {
          await updateDoc(doc(db, 'calls', activeCallId), { status: 'ended' });
          cleanupCall(); closeModal('callModal'); showToast('No answer', '');
        }
      } catch(e) {}
    }, 30000);
  };

  window.endCall = async function(updateFirestore = true) {
    closeModal('callModal');
    if (activeCallId && updateFirestore) {
      try { await updateDoc(doc(db, 'calls', activeCallId), { status: 'ended' }); } catch(e) {}
    }
    cleanupCall();
  };

  window.acceptCall = async function() {
    const bar = document.getElementById('incoming-call-bar');
    bar.classList.remove('visible');
    const cid = bar.dataset.callId;
    if (!cid) return;
    await getLocalAudio();
    const callSnap = await getDoc(doc(db, 'calls', cid));
    if (!callSnap.exists()) return;
    const d = callSnap.data();
    activeCallId = cid;
    currentCallParticipants = d.participants || [
      { uid: d.callerId, name: d.callerName, username: d.callerUsername, avatarUrl: d.callerAvatar },
      { uid: currentUser.uid, name: currentProfile.displayName || currentProfile.username, username: currentProfile.username, avatarUrl: currentProfile.avatarUrl || '' }
    ];
    await updateDoc(doc(db, 'calls', cid), { status: 'accepted' });
    renderCallModal(currentCallParticipants, 'Connected ✓');
    showCallPip('In call · ' + d.callerName, currentCallParticipants);
    openModal('callModal');
    // Answer WebRTC from caller
    await answerWebRTCFrom(d.callerId, cid);
    // Listen for end
    callUnsubscribe = onSnapshot(doc(db, 'calls', cid), snap => {
      if (!snap.exists() || snap.data().status === 'ended') { cleanupCall(); closeModal('callModal'); }
    });
  };

  window.declineCall = async function() {
    const bar = document.getElementById('incoming-call-bar');
    bar.classList.remove('visible');
    const cid = bar.dataset.callId;
    if (!cid) return;
    await updateDoc(doc(db, 'calls', cid), { status: 'declined' });
  };

  // Listen for incoming calls
  function listenForIncomingCalls() {
    onSnapshot(
      query(collection(db, 'calls'), where('recipientId', '==', currentUser.uid), where('status', '==', 'ringing')),
      snap => {
        const bar = document.getElementById('incoming-call-bar');
        if (snap.empty) { if (!activeCallId) bar.classList.remove('visible'); return; }
        const callDoc = snap.docs[0];
        const d = callDoc.data();
        const myStatus = currentProfile?.status || 'online';
        if (myStatus === 'dnd' || myStatus === 'invisible') {
          updateDoc(doc(db, 'calls', callDoc.id), { status: 'declined' }); return;
        }
        bar.dataset.callId = callDoc.id;
        const callerAvEl = document.getElementById('ic-caller-av');
        const myAvEl = document.getElementById('ic-my-av');
        callerAvEl.style.background = color(d.callerUsername || 'x');
        callerAvEl.innerHTML = d.callerAvatar ? `<img src="${d.callerAvatar}" style="width:100%;height:100%;object-fit:cover"/>` : (d.callerName?.[0] || '?').toUpperCase();
        myAvEl.style.background = color(currentProfile.username);
        myAvEl.innerHTML = currentProfile.avatarUrl ? `<img src="${currentProfile.avatarUrl}" style="width:100%;height:100%;object-fit:cover"/>` : (currentProfile.displayName || currentProfile.username)[0].toUpperCase();
        document.getElementById('ic-caller-name').textContent = d.callerName || 'Someone';
        bar.classList.add('visible');
      }
    );
  }

  // ── GROUP CHATS ──
  window.openNewGcModal = async function() {
    const friends = window._friends || [];
    const list = document.getElementById('gc-friends-list');
    list.innerHTML = '';
    document.getElementById('gc-name-input').value = '';
    if (!friends.length) { list.innerHTML = '<div style="color:var(--muted);font-size:0.85rem">No friends yet</div>'; }
    friends.filter(f => !f.deleted).forEach(f => {
      const name = f.displayName || f.username;
      const chip = document.createElement('div'); chip.className = 'gc-member-chip';
      chip.dataset.uid = f.id;
      chip.innerHTML = `<div class="chip-av" style="background:${color(f.username)}">${f.avatarUrl ? `<img src="${f.avatarUrl}" style="width:100%;height:100%;object-fit:cover;border-radius:50%"/>` : name[0].toUpperCase()}</div><span>${name}</span>`;
      chip.onclick = () => {
        const sel = list.querySelectorAll('.gc-member-chip.selected');
        if (!chip.classList.contains('selected') && sel.length >= 9) { showToast('Max 9 friends (10 total)', 'error'); return; }
        chip.classList.toggle('selected');
      };
      list.appendChild(chip);
    });
    openModal('newGcModal');
  };

  window.createGroupChat = async function() {
    const selected = [...document.querySelectorAll('.gc-member-chip.selected')];
    if (!selected.length) { showToast('Select at least one friend', 'error'); return; }
    const nameInput = document.getElementById('gc-name-input').value.trim();
    const memberIds = [currentUser.uid, ...selected.map(c => c.dataset.uid)];
    const gcName = nameInput || (selected.slice(0, 2).map(c => c.querySelector('span').textContent).join(', ') + (selected.length > 2 ? ` + ${selected.length - 2}` : ''));
    const gcRef = await addDoc(collection(db, 'groupChats'), {
      name: gcName, members: memberIds, createdBy: currentUser.uid, createdAt: serverTimestamp()
    });
    closeModal('newGcModal');
    showToast(`"${gcName}" created!`, 'success');
    await loadGroupChats();
    const gcSnap = await getDoc(gcRef);
    openGroupChat({ id: gcRef.id, ...gcSnap.data() });
  };

  async function loadGroupChats() {
    const snap = await getDocs(query(collection(db, 'groupChats'), where('members', 'array-contains', currentUser.uid)));
    const gcs = snap.docs.map(d => ({ id: d.id, ...d.data() }));
    window._groupChats = gcs;
    renderGcList(gcs);
  }

  function renderGcList(gcs) {
    let list = document.getElementById('gc-list');
    if (!list) return;
    list.innerHTML = '';
    if (!gcs.length) { list.innerHTML = '<div style="padding:4px 16px;font-size:0.78rem;color:var(--muted)">No group chats</div>'; return; }
    gcs.forEach(gc => {
      const div = document.createElement('div'); div.className = 'sidebar-item';
      div.innerHTML = `<div class="item-avatar" style="background:linear-gradient(135deg,#5b6af0,#e040fb);font-size:0.7rem">${gc.members.length}👥</div><span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${esc(gc.name || 'Group Chat')}</span>`;
      div.onclick = () => { closeMobileSidebar(); openGroupChat(gc); };
      list.appendChild(div);
    });
  }

  let gcUnsubscribe = null;
  let currentGc = null;

  function openGroupChat(gc) {
    currentGc = gc; currentDmFriend = null; currentServer = null; currentChannel = null;
    if (dmUnsubscribe) dmUnsubscribe();
    if (chUnsubscribe) chUnsubscribe();
    if (gcUnsubscribe) gcUnsubscribe();
    if (typingUnsubscribe) typingUnsubscribe();
    document.getElementById('profile-panel').classList.add('hidden');
    const content = document.getElementById('main-content');
    content.className = 'main-content chat-mode';

    // Build header
    const hdr = document.getElementById('main-header'); hdr.innerHTML = '';
    const hamBtn = document.createElement('button'); hamBtn.className = 'hamburger'; hamBtn.textContent = '☰'; hamBtn.onclick = toggleMobileSidebar; hdr.appendChild(hamBtn);
    const titleSpan = document.createElement('h2'); titleSpan.textContent = gc.name || 'Group Chat'; hdr.appendChild(titleSpan);
    const badge = document.createElement('span'); badge.className = 'gc-badge'; badge.textContent = `${gc.members.length} members`; hdr.appendChild(badge);
    const callBtn = document.createElement('button'); callBtn.className = 'friend-btn'; callBtn.textContent = '📞'; callBtn.title = 'Group Call'; callBtn.style.marginLeft = 'auto';
    callBtn.onclick = () => startGroupCall(gc); hdr.appendChild(callBtn);

    content.innerHTML = `<div class="chat-view"><div class="chat-messages" id="chat-messages"></div><div class="typing-indicator" id="typing-indicator"></div><div class="chat-input-area"><div class="chat-input-box"><button class="chat-attach-btn" onclick="document.getElementById('dm-file-input').click()">📎</button><input type="text" id="chat-input" placeholder="Message ${esc(gc.name || 'the group')}" onkeydown="if(event.key==='Enter')sendGcMsg()"/><button class="chat-send-btn" onclick="sendGcMsg()">➤</button></div></div></div>`;

    gcUnsubscribe = onSnapshot(query(collection(db, 'groupChats', gc.id, 'messages'), orderBy('createdAt')), async snap => {
      const container = document.getElementById('chat-messages'); if (!container) return;
      container.innerHTML = '';
      if (snap.empty) { container.innerHTML = `<div class="empty-state" style="flex:1"><div class="empty-icon">👋</div><h3>Welcome to ${esc(gc.name || 'the group')}!</h3><p>Say hi!</p></div>`; return; }
      // Pre-fetch senders
      const senderIds = [...new Set(snap.docs.map(d => d.data().senderId).filter(id => id && id !== currentUser.uid && !userCache[id]))];
      await Promise.all(senderIds.map(async id => { try { const s = await getDoc(doc(db,'users',id)); if(s.exists()) userCache[id]={id,...s.data()}; } catch(e){} }));
      snap.docs.forEach(d => renderMsg(d.data(), container, null, d.id, `groupChats/${gc.id}/messages`));
      container.scrollTop = container.scrollHeight;
    });
  }

  window.sendGcMsg = async function() {
    if (!currentGc) return;
    const input = document.getElementById('chat-input'); if (!input) return;
    const text = input.value.trim(); if (!text) return;
    input.value = '';
    await addDoc(collection(db, 'groupChats', currentGc.id, 'messages'), {
      text, senderId: currentUser.uid, senderName: currentProfile.displayName || currentProfile.username,
      senderUsername: currentProfile.username, senderAvatar: currentProfile.avatarUrl || '',
      type: 'text', createdAt: serverTimestamp()
    });
  };

  window.startGroupCall = async function(gc) {
    if (!gc) return;
    await getLocalAudio();
    const me = { uid: currentUser.uid, name: currentProfile.displayName || currentProfile.username, username: currentProfile.username, avatarUrl: currentProfile.avatarUrl || '' };
    // Get member profiles
    const memberProfiles = [me];
    for (const uid of gc.members.filter(id => id !== currentUser.uid)) {
      const u = userCache[uid] || (await getDoc(doc(db,'users',uid))).data();
      if (u) memberProfiles.push({ uid, name: u.displayName || u.username, username: u.username, avatarUrl: u.avatarUrl || '' });
    }
    currentCallParticipants = memberProfiles;
    const callRef = await addDoc(collection(db, 'calls'), {
      callerId: currentUser.uid, callerName: me.name, callerUsername: me.username, callerAvatar: me.avatarUrl,
      groupChatId: gc.id, groupName: gc.name || 'Group Chat',
      recipientIds: gc.members.filter(id => id !== currentUser.uid),
      participants: memberProfiles, status: 'ringing', type: 'group', createdAt: serverTimestamp(),
    });
    activeCallId = callRef.id;
    renderCallModal(memberProfiles, `Calling ${gc.name || 'group'}...`);
    showCallPip(gc.name || 'Group Call', memberProfiles);
    openModal('callModal');
    // Listen for participants joining
    callUnsubscribe = onSnapshot(doc(db, 'calls', callRef.id), snap => {
      if (!snap.exists()) { cleanupCall(); closeModal('callModal'); return; }
      const d = snap.data();
      if (d.status === 'ended') { cleanupCall(); closeModal('callModal'); }
      if (d.joinedUids) {
        d.joinedUids.forEach(uid => { if (uid !== currentUser.uid && !peerConnections[uid]) startWebRTCWith(uid, callRef.id); });
      }
    });
    // Mark self as joined
    await updateDoc(callRef, { joinedUids: [currentUser.uid] });
    // Listen for group incoming calls
    listenForGroupCallIncoming(callRef.id);
  };

  function listenForGroupCallIncoming(callId) {
    // Other members will see it via listenForGroupCalls below
  }

  // Listen for group call invites
  function listenForGroupCallInvites() {
    onSnapshot(
      query(collection(db, 'calls'),
        where('recipientIds', 'array-contains', currentUser.uid),
        where('status', '==', 'ringing'),
        where('type', '==', 'group')),
      snap => {
        const bar = document.getElementById('incoming-call-bar');
        if (snap.empty) return;
        const callDoc = snap.docs[0];
        const d = callDoc.data();
        const myStatus = currentProfile?.status || 'online';
        if (myStatus === 'dnd' || myStatus === 'invisible') {
          // Don't auto-decline group calls — just don't show banner
          return;
        }
        bar.dataset.callId = callDoc.id;
        bar.dataset.callType = 'group';
        const callerAvEl = document.getElementById('ic-caller-av');
        const myAvEl = document.getElementById('ic-my-av');
        callerAvEl.style.background = color(d.callerUsername || 'x');
        callerAvEl.innerHTML = d.callerAvatar ? `<img src="${d.callerAvatar}" style="width:100%;height:100%;object-fit:cover"/>` : (d.callerName?.[0] || '?').toUpperCase();
        myAvEl.style.background = color(currentProfile.username);
        myAvEl.innerHTML = currentProfile.avatarUrl ? `<img src="${currentProfile.avatarUrl}" style="width:100%;height:100%;object-fit:cover"/>` : (currentProfile.displayName || currentProfile.username)[0].toUpperCase();
        document.getElementById('ic-caller-name').textContent = d.groupName || d.callerName || 'Group Call';
        document.querySelector('.ic-sub').textContent = `${d.callerName} is calling the group...`;
        bar.classList.add('visible');
      }
    );
  }

  // Override acceptCall to handle group calls too
  const _originalAcceptCall = window.acceptCall;
  window.acceptCall = async function() {
    const bar = document.getElementById('incoming-call-bar');
    bar.classList.remove('visible');
    const cid = bar.dataset.callId;
    const ctype = bar.dataset.callType;
    if (!cid) return;
    await getLocalAudio();
    const callSnap = await getDoc(doc(db, 'calls', cid));
    if (!callSnap.exists()) return;
    const d = callSnap.data();
    activeCallId = cid;
    currentCallParticipants = d.participants || [];
    if (ctype === 'group') {
      // Join the group call
      const joined = d.joinedUids || [];
      if (!joined.includes(currentUser.uid)) joined.push(currentUser.uid);
      await updateDoc(doc(db, 'calls', cid), { joinedUids: joined });
      renderCallModal(currentCallParticipants, 'In group call');
      showCallPip(d.groupName || 'Group Call', currentCallParticipants);
      openModal('callModal');
      // Start WebRTC with everyone already joined
      for (const uid of (d.joinedUids || []).filter(u => u !== currentUser.uid)) {
        await answerWebRTCFrom(uid, cid);
      }
      callUnsubscribe = onSnapshot(doc(db, 'calls', cid), snap => {
        if (!snap.exists() || snap.data().status === 'ended') { cleanupCall(); closeModal('callModal'); }
      });
    } else {
      // 1:1 call
      await updateDoc(doc(db, 'calls', cid), { status: 'accepted' });
      renderCallModal(currentCallParticipants, 'Connected ✓');
      showCallPip('In call · ' + d.callerName, currentCallParticipants);
      openModal('callModal');
      await answerWebRTCFrom(d.callerId, cid);
      listenForScreenShares(cid);
      callUnsubscribe = onSnapshot(doc(db, 'calls', cid), snap => {
        if (!snap.exists() || snap.data().status === 'ended') { cleanupCall(); closeModal('callModal'); }
      });
    }
  };

  // ── VOICE CHANNELS IN SERVERS ──
  // Voice channels are type:'voice' in the channels collection
  // Members join by writing to voicePresence/{channelId}/members/{uid}
  // On leave, they're removed

  window.addVoiceChannel = async function(serverId) {
    const name = prompt('Voice channel name:');
    if (!name || !name.trim()) return;
    await addDoc(collection(db, 'channels'), {
      name: name.trim(), serverId, type: 'voice',
      permissions: { view: 'everyone', send: 'everyone' },
      createdAt: serverTimestamp()
    });
    showToast('Voice channel created!', 'success');
    await window.openServer(window.currentServer);
  };

  window.joinVoiceChannel = async function(ch, serverData) {
    if (activeCallId && activeCallId.startsWith('voice_')) {
      // Already in a voice channel, leave first
      await leaveVoiceChannel();
    }
    await getLocalAudio();
    const presenceRef = doc(db, 'voicePresence', ch.id, 'members', currentUser.uid);
    await setDoc(presenceRef, {
      uid: currentUser.uid, name: currentProfile.displayName || currentProfile.username,
      username: currentProfile.username, avatarUrl: currentProfile.avatarUrl || '',
      joinedAt: serverTimestamp()
    });
    // Pre-create signaling docs for anyone already in the channel (done in startWebRTCWith/answerWebRTCFrom)

    activeCallId = 'voice_' + ch.id;
    currentCallParticipants = [{ uid: currentUser.uid, name: currentProfile.displayName || currentProfile.username, username: currentProfile.username, avatarUrl: currentProfile.avatarUrl || '' }];

    // Show pip
    showCallPip('🔊 ' + ch.name, currentCallParticipants);
    renderCallModal(currentCallParticipants, '🔊 Voice: #' + ch.name);
    openModal('callModal');

    listenForScreenShares('voice_' + ch.id);
    // Listen for presence changes and do WebRTC
    callUnsubscribe = onSnapshot(collection(db, 'voicePresence', ch.id, 'members'), async snap => {
      const members = snap.docs.map(d => d.data());
      currentCallParticipants = members;
      renderCallModal(members, '🔊 Voice: #' + ch.name);
      showCallPip('🔊 ' + ch.name, members);
      // Connect to anyone new:
      // - If they were already here (joinedAt older), WE are the newcomer → we answer (their offer)
      // - If they just joined (joinedAt recent), THEY are the newcomer → we offer to them
      const myJoinTime = Date.now() / 1000;
      for (const m of members.filter(m => m.uid !== currentUser.uid)) {
        if (peerConnections[m.uid]) continue; // already connected
        const theirJoinSeconds = m.joinedAt?.seconds || 0;
        const theyJoinedRecently = theirJoinSeconds > (myJoinTime - 8);
        if (theyJoinedRecently) {
          // They just joined — we're the established one — we offer
          await startWebRTCWith(m.uid, 'voice_' + ch.id);
        } else {
          // We just joined — they're established — we answer their offer
          await answerWebRTCFrom(m.uid, 'voice_' + ch.id);
        }
      }
      // Update sidebar
      updateVoiceChannelUI(ch.id, members);
    });
    // Remove presence on close
    window._voiceLeaveRef = presenceRef;
    window._voiceChannelId = ch.id;
  };

  async function leaveVoiceChannel() {
    if (window._voiceLeaveRef) {
      try { await deleteDoc(window._voiceLeaveRef); } catch(e) {}
      window._voiceLeaveRef = null;
    }
    cleanupCall();
  }

  // Override endCall for voice channels
  const _baseEndCall = window.endCall;
  window.endCall = async function(updateFirestore = true) {
    closeModal('callModal');
    if (activeCallId && activeCallId.startsWith('voice_')) {
      await leaveVoiceChannel();
    } else if (activeCallId && updateFirestore) {
      try { await updateDoc(doc(db, 'calls', activeCallId), { status: 'ended' }); } catch(e) {}
      cleanupCall();
    } else {
      cleanupCall();
    }
  };

  function updateVoiceChannelUI(channelId, members) {
    const vcEl = document.getElementById('vc-' + channelId);
    if (!vcEl) return;
    // Update participant list below channel
    let partList = document.getElementById('vcp-' + channelId);
    if (!partList) {
      partList = document.createElement('div'); partList.className = 'voice-participants'; partList.id = 'vcp-' + channelId;
      vcEl.insertAdjacentElement('afterend', partList);
    }
    partList.innerHTML = '';
    const inCall = members.some(m => m.uid === currentUser.uid);
    vcEl.classList.toggle('in-call', inCall);
    members.forEach(m => {
      const row = document.createElement('div'); row.className = 'voice-participant';
      row.innerHTML = `<div class="vp-av" style="background:${color(m.username||'x')}">${m.avatarUrl?`<img src="${m.avatarUrl}" style="width:100%;height:100%;object-fit:cover;border-radius:50%"/>`:m.name?.[0]||'?'}</div><span>${esc(m.name||m.username)}</span>`;
      partList.appendChild(row);
    });
  }

    // ── NOTIFICATION SOUND (soft ping using Web Audio API) ──
  function playNotifSound() {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = ctx.createOscillator(); const gain = ctx.createGain();
      osc.connect(gain); gain.connect(ctx.destination);
      osc.type = 'sine'; osc.frequency.setValueAtTime(880, ctx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(660, ctx.currentTime + 0.15);
      gain.gain.setValueAtTime(0.18, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);
      osc.start(ctx.currentTime); osc.stop(ctx.currentTime + 0.4);
    } catch(e) {}
  }

  // ── LAST ACTIVE HEARTBEAT (updates every 2 min while tab is open) ──
  function startPresenceHeartbeat() {
    async function beat() {
      if (!currentUser || !currentProfile) return;
      // Don't overwrite manual DND/invisible
      if (currentProfile.manualStatus === 'dnd' || currentProfile.manualStatus === 'invisible') return;
      try { await updateDoc(doc(db,'users',currentUser.uid), { lastActive: serverTimestamp(), status: 'online' }); } catch(e) {}
    }
    beat();
    setInterval(beat, 120000); // every 2 min
    // Mark offline when tab closes
    window.addEventListener('beforeunload', async () => {
      if (currentUser && currentProfile?.manualStatus !== 'invisible') {
        try { await updateDoc(doc(db,'users',currentUser.uid), { lastActive: serverTimestamp(), status: 'offline' }); } catch(e) {}
      }
    });
  }

  // ── UNREAD DM TRACKING ──
  const unreadDms = new Set(); // friend UIDs with unread messages
  function markUnread(friendId) {
    if (currentDmFriend?.id === friendId) return; // already viewing this DM
    unreadDms.add(friendId);
    // Find sidebar item and add unread dot
    const items = document.querySelectorAll('#dm-list .sidebar-item');
    items.forEach(item => {
      if (item._friendId === friendId) item.classList.add('unread');
    });
    // Update mobile nav badge
    const badge = document.getElementById('mnav-dms');
    if (badge) badge.dataset.badge = unreadDms.size > 0 ? unreadDms.size : '';
  }
  function markRead(friendId) {
    unreadDms.delete(friendId);
    const items = document.querySelectorAll('#dm-list .sidebar-item');
    items.forEach(item => { if (item._friendId === friendId) item.classList.remove('unread'); });
    const badge = document.getElementById('mnav-dms');
    if (badge) badge.dataset.badge = unreadDms.size > 0 ? unreadDms.size : '';
  }

  // ── SIGN OUT ──
  window.handleSignOut=async function(){ try{await updateDoc(doc(db,'users',currentUser.uid),{status:'offline'});}catch(e){} await signOut(auth); window.location.href='index.html'; };

  // ── NAV ──
  window.showView=function(){
    document.querySelectorAll('.server-icon').forEach(i=>i.classList.remove('active'));
    document.querySelector('.server-icon.home').classList.add('active');
    document.getElementById('profile-panel').classList.add('hidden');
    currentServer=null; currentChannel=null; currentDmFriend=null;
    // Reset sidebar to DMs
    document.getElementById('sidebar-title').textContent='💬 Direct Messages';
    document.getElementById('sidebar-action-btn').innerHTML='+';
    document.getElementById('sidebar-action-btn').onclick=()=>openModal('addFriendModal');
    const scroll=document.getElementById('sidebar-scroll'); scroll.innerHTML='<div class="sidebar-section-label">DIRECT MESSAGES <button class="sl-btn" onclick="openNewGcModal()">+</button></div><div id="dm-list"></div><div class="sidebar-section-label" style="margin-top:8px">GROUP CHATS <button class="sl-btn" onclick="openNewGcModal()">+</button></div><div id="gc-list"></div>';
    renderDmList(window._friends||[]);
    document.getElementById('main-content').className='main-content';
    document.getElementById('main-header').innerHTML=`<button class="hamburger" onclick="toggleMobileSidebar()">☰</button><span>👥</span><h2>Friends</h2><div class="header-tabs"><button class="tab active" onclick="switchTab(this,'online')">Online</button><button class="tab" onclick="switchTab(this,'all')">All</button><button class="tab" onclick="switchTab(this,'pending')">Pending&nbsp;<span id="pending-count" style="display:none" class="pending-badge">0</span></button></div><button class="add-friend-btn" onclick="openModal('addFriendModal')">+ Add Friend</button>`;
    renderFriendsView(window._friends||[]);
  };
  window.switchTab=function(btn,tab){ document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active')); btn.classList.add('active'); if(tab==='pending') renderPendingView(); else renderFriendsView(window._friends||[]); };
  window.selectServerType=card=>{ document.querySelectorAll('.server-type-card').forEach(c=>c.classList.remove('selected')); card.classList.add('selected'); };
  window.filterSidebar=function(){ /* basic client-side filter */ };

  // ── MOBILE ──
  window.toggleMobileSidebar=function(){ document.getElementById('sidebar').classList.toggle('open'); document.getElementById('sidebar-overlay').classList.toggle('open'); };
  window.closeMobileSidebar=function(){ document.getElementById('sidebar').classList.remove('open'); document.getElementById('sidebar-overlay').classList.remove('open'); };
  window.mobileNav=function(tab,btn){
    document.querySelectorAll('.mobile-nav-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    if (tab==='home') showView();
    else if (tab==='dms') { showView(); }
    else if (tab==='servers') showMobileServerSheet();
  };

  // ── MOBILE SERVER SHEET ──
  window.showMobileServerSheet = function() {
    // Remove existing sheet if any
    const existing = document.getElementById('mobile-server-sheet');
    if (existing) { existing.remove(); return; }

    const servers = window._servers || [];
    const sheet = document.createElement('div');
    sheet.id = 'mobile-server-sheet';
    sheet.style.cssText = `position:fixed;bottom:var(--mobile-nav-h);left:0;right:0;background:var(--surface);border-top:1px solid var(--border);border-radius:20px 20px 0 0;z-index:250;padding:16px;max-height:70vh;overflow-y:auto;box-shadow:0 -8px 32px rgba(0,0,0,0.4);animation:slideUp 0.25s ease`;

    let html = `<div style="width:40px;height:4px;background:var(--border);border-radius:2px;margin:0 auto 16px"></div>
      <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:1.1rem;margin-bottom:14px">Your Servers</div>`;

    if (!servers.length) {
      html += `<div style="text-align:center;color:var(--muted);font-size:0.88rem;padding:20px 0">No servers yet</div>`;
    } else {
      servers.forEach(s => {
        html += `<div onclick="closeMobileServerSheet();openServer(window._servers.find(x=>x.id==='${s.id}'))" style="display:flex;align-items:center;gap:12px;padding:10px;border-radius:10px;cursor:pointer;transition:background 0.15s;margin-bottom:4px" onmouseover="this.style.background='var(--surface2)'" onmouseout="this.style.background=''">
          <div style="width:44px;height:44px;border-radius:14px;background:${color(s.name)};color:#fff;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:1.1rem;flex-shrink:0">${s.name[0].toUpperCase()}</div>
          <div>
            <div style="font-weight:600;font-size:0.92rem">${esc(s.name)}</div>
            <div style="font-size:0.74rem;color:var(--muted)">${s.ownerId===currentUser.uid?'Owner':'Member'}</div>
          </div>
        </div>`;
      });
    }

    html += `<div style="border-top:1px solid var(--border);margin-top:12px;padding-top:12px;display:flex;gap:8px">
      <button onclick="closeMobileServerSheet();openModal('createServerModal')" style="flex:1;padding:11px;background:var(--accent);color:#fff;border:none;border-radius:8px;font-family:'DM Sans',sans-serif;font-size:0.86rem;font-weight:600;cursor:pointer">➕ Create</button>
      <button onclick="closeMobileServerSheet();openModal('joinServerModal')" style="flex:1;padding:11px;background:var(--surface2);color:var(--text);border:none;border-radius:8px;font-family:'DM Sans',sans-serif;font-size:0.86rem;font-weight:600;cursor:pointer">🔗 Join</button>
    </div>`;

    sheet.innerHTML = html;
    document.body.appendChild(sheet);

    // Tap outside to close
    setTimeout(() => {
      document.addEventListener('click', function handler(e) {
        if (!sheet.contains(e.target) && e.target.id !== 'mnav-servers') {
          closeMobileServerSheet();
          document.removeEventListener('click', handler);
        }
      });
    }, 50);
  };

  window.closeMobileServerSheet = function() {
    const sheet = document.getElementById('mobile-server-sheet');
    if (sheet) sheet.remove();
  };

  // ── UTILS ──
  function color(str){ if(!str) return '#5b6af0'; let h=0; for(let i=0;i<str.length;i++) h=str.charCodeAt(i)+((h<<5)-h); return ['#5b6af0','#e040fb','#00bcd4','#ff7043','#66bb6a','#ffa726','#ab47bc','#26c6da'][Math.abs(h)%8]; }
  function esc(t){ return String(t).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }
  function sj(obj){ return "JSON.parse('"+JSON.stringify(obj).replace(/\\/g,'\\\\').replace(/'/g,"\\'")+"')"; }
  function fmtSize(b){ if(b<1024) return b+' B'; if(b<1048576) return (b/1024).toFixed(1)+' KB'; return (b/1048576).toFixed(1)+' MB'; }
  function fileIcon(name){ const e=(name||'').split('.').pop().toLowerCase(); return {pdf:'📄',doc:'📝',docx:'📝',txt:'📄',zip:'🗜️',rar:'🗜️',mp3:'🎵',wav:'🎵',mp4:'🎬',mov:'🎬'}[e]||'📁'; }
  function showToast(msg,type){ const t=document.getElementById('toast'); t.textContent=msg; t.className=`toast ${type} show`; setTimeout(()=>{t.className='toast';},3500); }
  window.showToast=showToast;
  // expose for inline HTML access
  Object.defineProperty(window, '_currentUid', { get: () => currentUser?.uid });
  window.currentServer=currentServer; // expose for inline onclick


  // ─────────────────────────────────────────────────────────────
  //  MESSAGE REPORT SYSTEM (dashboard)
  // _____________________________________________________________
  const MSG_REPORT_PRESETS = [
    'Spam or ads', 'Hate speech', 'Harassment / bullying',
    'Sexual content', 'Violence or threats', 'Scam / phishing', 'Other'
  ];
  let _dashReportTarget   = null;
  let _dashSelectedPreset = null;

  const esc2 = s => String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');

  window.openMsgReport = async function(data, docId, collPath, senderName) {
    _dashReportTarget   = { data, docId, collPath, senderName };
    _dashSelectedPreset = null;
    document.getElementById('dash-report-label').textContent = 'Message from @' + (senderName||'unknown');
    document.getElementById('dash-report-custom').value = '';

    // Fetch up to 5 messages ending at this one for context
    let ctxMsgs = [];
    try {
      const snap = await getDocs(query(collection(db, collPath), orderBy('createdAt','asc'), limit(80)));
      const all  = snap.docs.map(d2=>({id:d2.id,...d2.data()}));
      const idx  = all.findIndex(m=>m.id===docId);
      const start = Math.max(0, idx-4);
      ctxMsgs = all.slice(start, idx+1);
    } catch(e) {}

    _dashReportTarget.context = ctxMsgs.map(m=>({
      id:m.id, text:m.text||'', isFlagged:m.id===docId,
      ts:m.createdAt?.toMillis?.()??0, authorUid:m.senderId||''
    }));

    const ctxEl = document.getElementById('dash-report-context');
    if (ctxMsgs.length) {
      ctxEl.innerHTML = ctxMsgs.map(m=>{
        const flagged = m.id===docId;
        const txt = esc2((m.text||'[media/file]').substring(0,100));
        const name2 = esc2(m.senderName||'?');
        return `<div style="padding:3px 6px;border-radius:4px;margin-bottom:2px${flagged?';background:rgba(229,57,53,.12);border-left:2px solid #e53935;padding-left:8px':''}">
          ${flagged?'<span style="font-size:0.72rem">⚠️ </span>':'<span style="color:var(--muted);font-size:0.72rem">◦ </span>'}
          <strong style="font-size:0.75rem">${name2}:</strong> <span>${txt}</span></div>`;
      }).join('');
    } else {
      ctxEl.textContent = '(Context unavailable)';
    }

    // Preset chips
    document.getElementById('dash-report-presets').innerHTML =
      MSG_REPORT_PRESETS.map(p =>
        `<button class="dash-report-chip" onclick="selectDashPreset(this,'${p.replace(/'/g,"\'")}')">` + p + '</button>'
      ).join('');

    document.getElementById('dashReportModal').style.display = 'flex';
  };

  window.selectDashPreset = function(btn, preset) {
    _dashSelectedPreset = preset;
    document.querySelectorAll('.dash-report-chip').forEach(c=>c.classList.remove('selected'));
    btn.classList.add('selected');
  };

  window.closeDashReport = function() {
    document.getElementById('dashReportModal').style.display = 'none';
    _dashReportTarget = null; _dashSelectedPreset = null;
  };

  window.submitDashReport = async function() {
    if (!_dashReportTarget) return;
    const custom = document.getElementById('dash-report-custom').value.trim();
    if (!_dashSelectedPreset && !custom) { showToast('Please select a reason', 'error'); return; }
    const btn = document.getElementById('dash-report-submit');
    btn.disabled = true; btn.textContent = 'Sending…';
    try {
      await addDoc(collection(db,'reports'), {
        type: 'message',
        targetId:    _dashReportTarget.docId,
        targetLabel: 'Message from @' + (_dashReportTarget.senderName||'?') + ' [' + _dashReportTarget.collPath + ']',
        reporterUid: currentUser.uid,
        preset:      _dashSelectedPreset || '(custom)',
        custom,
        context:     _dashReportTarget.context || [],
        collPath:    _dashReportTarget.collPath,
        status:      'open',
        createdAt:   serverTimestamp(),
      });
      closeDashReport();
      showToast('Report submitted — our team will review it.', 'success');
    } catch(e) {
      console.error('submitDashReport error:', e);
      showToast('Report failed: ' + (e.code||e.message||'unknown error'), 'error');
    } finally {
      btn.disabled = false; btn.textContent = 'Submit Report';
    }
  };

</script>

<script>
  function openModal(id){ document.getElementById(id).classList.add('open'); }
  function closeModal(id){ document.getElementById(id).classList.remove('open'); }
  document.querySelectorAll('.modal-overlay').forEach(o=>{ o.addEventListener('click',e=>{ if(e.target===o) o.classList.remove('open'); }); });
  document.addEventListener('keydown',e=>{ if(e.key==='Escape') document.querySelectorAll('.modal-overlay.open').forEach(m=>m.classList.remove('open')); });
</script>

<!-- REPORT MODAL (Dashboard messages) -->
<div id="dashReportModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.72);z-index:600;align-items:center;justify-content:center;padding:16px">
  <div style="background:var(--surface);border:1px solid var(--border2);border-radius:16px;padding:24px;max-width:500px;width:100%;max-height:90vh;overflow-y:auto">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:16px">
      <h3 style="font-family:'Syne',sans-serif;font-weight:700;font-size:1.05rem">🚩 Report</h3>
      <button onclick="window.closeDashReport()" style="background:none;border:none;color:var(--muted);cursor:pointer;font-size:1.3rem;line-height:1">×</button>
    </div>
    <p id="dash-report-label" style="font-size:0.82rem;color:var(--muted);margin-bottom:12px"></p>
    <div style="font-size:0.72rem;font-weight:700;text-transform:uppercase;letter-spacing:.06em;color:var(--muted);margin-bottom:4px">Message context (last 5)</div>
    <div id="dash-report-context" style="background:var(--surface2);border:1px solid var(--border);border-radius:8px;padding:10px;margin-bottom:14px;max-height:130px;overflow-y:auto;font-size:0.82rem;color:#c8cce0"></div>
    <div style="font-size:0.72rem;font-weight:700;text-transform:uppercase;letter-spacing:.06em;color:var(--muted);margin-bottom:8px">Reason</div>
    <div id="dash-report-presets" style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:12px"></div>
    <textarea id="dash-report-custom" placeholder="Add more details (optional)…" maxlength="500"
      style="width:100%;background:var(--surface2);border:1px solid var(--border);border-radius:10px;padding:10px 12px;color:var(--text);font-family:'DM Sans',sans-serif;font-size:0.88rem;resize:none;outline:none;min-height:64px;box-sizing:border-box"></textarea>
    <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:14px">
      <button onclick="window.closeDashReport()" style="padding:9px 20px;background:var(--surface2);border:1px solid var(--border);border-radius:100px;color:var(--text);font-family:'DM Sans',sans-serif;font-weight:600;cursor:pointer;font-size:0.88rem">Cancel</button>
      <button id="dash-report-submit" onclick="window.submitDashReport()" style="padding:9px 20px;background:#e53935;border:none;border-radius:100px;color:#fff;font-family:'DM Sans',sans-serif;font-weight:700;cursor:pointer;font-size:0.88rem">Submit Report</button>
    </div>
  </div>
</div>
</body>
</html>
